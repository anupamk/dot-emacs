# -*- indent-tabs-mode: nil; lexical-binding: t; -*-
#+TITLE: GNU Emacs Configuration
#+AUTHOR: Anupam Kapoor
#+EMAIL: anupam.kapoor@gmail.com
#+STARTUP: show2levels hidestars
#+PROPERTY: header-args :tangle yes
# ----------------------------  ^^^ tangle all code blocks.

* Use Package Syntax Reminder & Sundry Notes
** Use Package
  The =use-package= macro is used to install, configure and load
  packages that we are using in our configuration.

  This is just a quick syntax reminder for its day-to-day usage. For
  way more information, see [[https://github.com/jwiegley/use-package#getting-started][this]] or [[https://jwiegley.github.io/use-package/keywords/][this]].

  + =:config= and =:init=

    The =:config= and =:init= keywords define code that is run right
    after or right before a package is loaded /respectively/.

    Thus if a package =foo= offers a configuration option
    =conf-foo-doo= we can do this

    # -------------------- vvvvv no tangling these stanzas
    #+begin_src emacs-lisp :tangle no

      (use-package foo

        ;; ---------------------------------------------------------------------
        ;; execute code before package is loaded
        :init
        (setq conf-foo-doo nil)

        ;; ---------------------------------------------------------------------
        ;; execute code after package is loaded
        :config
        (foo-mode)
        )

    #+end_src

  + =:bind=

    Adds keybindings after a module is loaded. For example, to use
    =consult-buffer= instead of the canonical =switch-to-buffer= after
    =consult= is loaded, do this:

    #+begin_src emacs-lisp :tangle no

      (use-package consult
        :bind
        ("C-x b" . consult-buffer)
        )

    #+end_src

  + =:custom=

    This allows customizations of a package's custom variables. Thus
    for example, doing this:

    #+begin_src emacs-lisp :tangle no

      (use-package straight
        :custom
        (straight-use-package-by-default t)
        )

    #+end_src

    sets `straight-use-package-by-default' after loading straight.el

  + =:hook=

    This allows adding functions onto package hooks. When using the
    =:hook= we must /remember/ to *omit* the =-hook= suffix, as this
    is appended by default.

    Thus for example, when adding some customizations for =cc-mode=
    we need to do this

    #+begin_src emacs-lisp :tangle no

      (use-package cc-mode
        :hook
        (c-mode-common . exec-c-mode-common-hook-func))

    #+end_src

    Note that in the =:hook= section above, we have just used
    =c-mode-common= and not =c-mode-common-hook= !

  + =:if, :when, :unless=

    With these keywords packages can be conditionally loaded. This is
    quite handy for example when some packages make sense to be loaded
    in some environments only.

    Thus, suppose we want to load a package / configuration on host
    'astra' and a different one on host 'aws-devel-01' we can do the
    following:

    #+begin_src emacs-lisp :tangle no

    (use-package emacs
      :if (anupamk:utils/host-name-is "astra")
      :init
      (message "now running on 'astra'")
      )

    #+end_src

    Once this snippet of code is loaded, you will see the following in
    the =*Messages*= buffers

    #+begin_src emacs-lisp :tangle no

       now running on 'astra'

    #+end_src

  + =:commands=

    When you use the :commands keyword, it creates autoloads for those
    commands and defers loading of the module until they are used.

  + =:demand=

    The keywords :commands, et al, provide "triggers" that cause a
    package to be loaded when certain events occur. The presence of
    triggers can be overridden using =:demand t= to force immediately
    loading anyway.


** Emacs Lisp
+ In Emacs Lisp, if =foo= is a symbol, then ='foo= and =#'foo= are
  completely equivalent. The latter form (with =#'=) is preferred when
  =foo= is a function, as it documents the fact that it is intended to
  be funcalled.

+ "Backquote" constructs allow you to quote a list, but selectively
  evaluate elements within that list. This gives us the following:

#+begin_src emacs-lisp :tangle no

(setq a "a value")
(setq b "b value")
(setq c "c value")

'(a b c)            ; => (a b c)
`(,a b c)           ; => ("a value" b c)

#+end_src


* Base Settings
** Encoding

#+begin_src emacs-lisp

;; -----------------------------------------------------------------------------
;; prefer utf-8 encoding everywhere.
(set-default-coding-systems   'utf-8)
(prefer-coding-system         'utf-8)
(set-terminal-coding-system   'utf-8)
(set-keyboard-coding-system   'utf-8)
(set-language-environment     'utf-8)
(set-selection-coding-system  'utf-8)

(setq locale-coding-system    'utf-8  ; coding system to use with system messages
      coding-system-for-read  'utf-8  ; coding system for read operations
      coding-system-for-write 'utf-8) ; coding system for write operations

;; -----------------------------------------------------------------------------
;; cons of coding system used for process i/o
(setq default-process-coding-system '(utf-8-unix ; decoding process output
                                      .
                                      utf-8-unix)) ; encoding process input

#+end_src

** Recovery
When either Emacs or the computer it is running on crashes, files that
you are currently editing can be recovered.

This is done using the =M-x recover-session=, we now configure how
files are saved in the background.

#+begin_src emacs-lisp

  (setq auto-save-list-file-prefix ; Prefix for generating auto-save-list-file-name
        (expand-file-name ".auto-save-list/.saves-" user-emacs-directory)
        auto-save-default t        ; Auto-save every buffer that visits a file
        auto-save-timeout 20       ; Number of seconds between auto-save
        auto-save-interval 200)    ; Number of keystrokes between auto-saves

#+end_src

** Backups
Configure how Emacs backs the files up

#+begin_src emacs-lisp

  (setq backup-directory-alist       ; File name patterns and backup directory names.
        `(("." . ,(expand-file-name "backups" user-emacs-directory)))
        make-backup-files t          ; Backup of a file the first time it is saved.
        vc-make-backup-files nil     ; No backup of files under version control
        backup-by-copying t          ; Don't clobber symlinks
        version-control t            ; Version numbers for backup files
        delete-old-versions t        ; Delete excess backup files silently
        kept-old-versions 6          ; Number of old versions to keep
        kept-new-versions 9          ; Number of new versions to keep
        delete-by-moving-to-trash t) ; Delete files to trash

#+end_src

** Disable gooey
I just want bare-bones windows with the modeline. GUI toolkit (gtk3
these days) components f.e buttons, scroll-bars etc. don't really have
any utility for me.

#+begin_src emacs-lisp

(use-package emacs

  :init
  ;; ---------------------------------------------------------------------------
  ;; remove gui toolkit components that are of limited use for me
  (blink-cursor-mode -1)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (horizontal-scroll-bar-mode -1)

  ;; ---------------------------------------------------------------------------
  ;; i need some space man
  (setq-default line-spacing 0.1)

  ;; ---------------------------------------------------------------------------
  ;; if mouse commands use a file-dialog to ask for files
  (setq use-file-dialog nil)

  ;; ---------------------------------------------------------------------------
  ;; mouse commands use a dialogue box to ask questions
  (setq use-dialog-box t)

  ;; ---------------------------------------------------------------------------
  ;; which keys Emacs uses for alt modifier
  (setq x-alt-keysym 'meta)

  :bind
  (("C-z"     . nil)
   ("C-x C-z" . nil)
   ("C-h h"   . nil)))

#+end_src

** Delight
Edit / Rename / Remove (most often) modeline lighters for different
packages.

#+begin_src emacs-lisp

(use-package delight
  :after use-package)

(use-package gcmh
  :delight)

#+end_src

** Whitespaces
Highlight trailing space-like characters f.e. tabs, empty lines,
trailing spaces etc.

#+begin_src emacs-lisp

(use-package whitespace
  :delight

  :hook
  (prog-mode   . whitespace-mode)
  (text-mode   . whitespace-mode)
  (before-save . whitespace-cleanup)

  :custom
  (whitespace-style '(trailing))
  )

#+end_src

** Autofilling

#+begin_src emacs-lisp

(auto-fill-mode t)

#+end_src

** Start Server
Start emacs-server if it is not running already. New frames can
connect to a running instance with =emacsclient -c= invokation.

#+begin_src emacs-lisp

(unless (and (fboundp 'server-running-p)
             (server-running-p))
  (server-start))

#+end_src

** Location of user customizations
Store all user customizations in a separate disposable location for
sane behavior.

#+begin_src emacs-lisp

;; ---------------------------------------------------------------------------
;; customizations in a separate place all together
(defvar customization-fname "emacs-custom.el"
  "personal customization locations")

(setq custom-file (expand-file-name customization-fname user-emacs-directory))

;; ---------------------------------------------------------------------------
;; load customizations once initialization is complete
(defun anupamk:utils/load-customizations ()
  (when (file-exists-p custom-file)
    (load-file custom-file)))

(add-hook 'after-init-hook #'anupamk:utils/load-customizations)

#+end_src

** Unannoy
Saner defaults (from my perspective anyways) makes the whole thing so
much better.

#+begin_src emacs-lisp

(use-package emacs

  :init

  ;; -------------------------------------------------------------------------
  ;; no scratchpad by default, we can always create one ourselves.
  ;; see `anupamk:utils/create-new-scratch-buffer' for more details
  (setf initial-scratch-message nil)

  ;; -------------------------------------------------------------------------
  ;; look ma, nobell
  (setf ring-bell-function (lambda()))

  ;; -------------------------------------------------------------------------
  ;; littering is a punishable offence in this and other states.
  (setf backup-inhibited t
        auto-save-default nil
        make-backup-files nil
        create-lockfiles nil)

  ;; -------------------------------------------------------------------------
  ;; prefix for generating auto-save-list-file-name
  (setf auto-save-list-file-prefix (locate-user-emacs-file "local/saves"))

  ;; -------------------------------------------------------------------------
  ;; echo unfinished commands after 0.1 seconds of pause
  (setf echo-keystrokes 0.1)

  ;; -------------------------------------------------------------------------
  ;; allow single character to delete a region
  (setf delete-active-region nil)

  ;; -------------------------------------------------------------------------
  ;; nullify function that is invoked to handle disabled commands i.e. all
  ;; commands work normally
  (setf disabled-command-function nil)

  ;; -------------------------------------------------------------------------
  ;; prefer loading newer `.el' files over older `.elc'
  (setf load-prefer-newer t)

  ;; -------------------------------------------------------------------------
  ;; enable column numbers
  (setq column-number-mode t)

  ;; -------------------------------------------------------------------------
  ;; merge system and emacs clipboard
  (setq select-enable-clipboard t)
  (setq select-enable-primary t)

  ;; -------------------------------------------------------------------------
  ;; get rid of the insert key
  (define-key global-map [(insert)] nil)

  ;; -------------------------------------------------------------------------
  ;; disable full 'yes' or 'no' (from emacs-28 onwards)
  (setq use-short-answers t)

  ;; -------------------------------------------------------------------------
  ;; no tabs in sources
  (setq-default indent-tabs-mode nil)

  ;; -------------------------------------------------------------------------
  ;; display buffer at its previous position
  (setq switch-to-buffer-preserve-window-point t)

  ;; -------------------------------------------------------------------------
  ;; with 'complete, <TAB> first tries to indent the current line,
  ;; and if the line was already indented, then try to complete the
  ;; thing at point.
  (setq tab-always-indent 'complete)

  ;; -------------------------------------------------------------------------
  ;; all themes are safe
  (setq custom-safe-themes t)

  ;; -------------------------------------------------------------------------
  ;; write over selected text on input. just like other editors.
  (delete-selection-mode t)

  ;; -------------------------------------------------------------------------
  ;; less noisy emacs-lisp compilation
  (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
  (setq native-comp-async-report-warnings-errors nil)

  ;; -------------------------------------------------------------------------
  ;; max number of bytes to read from a process in a single chunk. 8m
  ;; is reasonable for lsp based programming...
  (setq read-process-output-max (* 8 1024 1024))

  ;; -------------------------------------------------------------------------
  ;; focus on help windows when opened
  (setq-default help-window-select t)

  ;; -------------------------------------------------------------------------
  ;; avoid recentering when scrolling far
  (setq-default scroll-conservatively 101)

  ;; -------------------------------------------------------------------------
  ;; add a margin when scrolling vertically
  (setq-default scroll-margin 2)

  ;; -------------------------------------------------------------------------
  ;; resize window proportionally
  (setq-default window-combination-resize t)

  ;; -------------------------------------------------------------------------
  ;; when non-nil left and right side windows occupy full height. when
  ;; 'nil' top and bottom-side windows occupy full frame width
  (setq-default window-sides-vertical nil)

  ;; -------------------------------------------------------------------------
  ;; enable downcase-region and upcase-region
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)

  ;; -------------------------------------------------------------------------
  ;; enable recursive minibuffers (launch command that use the
  ;; minibuffer while already inside a minibuffer)
  (setq enable-recursive-minibuffers t)

  ;; -------------------------------------------------------------------------
  ;; what to do if we follow a symbolic link to a file under version
  ;; control. with `t', vc follows the link and visits the real file
  ;; (telling about it in the echo area)
  (setf vc-follow-symlinks t)
  )

#+end_src

Default mouse behavior in Emacs can be augmented with some saner defaults.

#+begin_src emacs-lisp

  (use-package emacs
    :config
    ;; -------------------------------------------------------------------------
    ;; some semblance of mouse sanity in emacs

    ;; enable `sloppy' focus on emacs-frames aka what is good in fvwm2 is also
    ;; good in emacs
    (setq mouse-autoselect-window t)

    ;; copy to kill-ring upon mouse adjustments of the region.
    (setq mouse-drag-copy-region t)

    ;; resize frames independent of `frame-char-{height,width}'
    (setq frame-resize-pixelwise t)

    ;; -------------------------------------------------------------------------
    ;; how much should we scroll when the mouse-wheel is spun around ? when the
    ;; <CTRL> key is held, change the size of text in the buffer
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)
                                        ((control) . text-scale)))
    )

#+end_src

** Performance
Ensure that gc never occurs while minibuffer is open, but once we make
a selection (or cancecl), GC will kick off, and we revert back to
default sensible behavior.

#+begin_src emacs-lisp

(defun my-minibuffer-setup-hook ()
  "Garbage collection will never occur."
  (setq gc-cons-threshold most-positive-fixnum))

(defun my-minibuffer-exit-hook ()
  "Garbage collection will kick off immediately."
  (setq gc-cons-threshold gc-cons-threshold-original))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)

#+end_src

GC on focus out

#+begin_src emacs-lisp

(add-hook 'focus-out-hook #'garbage-collect)

#+end_src

Dont steal focus while performing async compilations

#+begin_src emacs-lisp

(setq warning-suppress-types '((comp)))

#+end_src

Potential speedup of cursor operations

#+begin_src emacs-lisp

(setq auto-window-vscroll nil)

#+end_src


* Utility Functions
** Commonly used utility functions

#+begin_src emacs-lisp

;; -----------------------------------------------------------------------------
;; insert current date
(defun anupamk:utils/insert-current-date (iso)
  " Insert the current date at point.
          When ISO is non-nil, insert the date in ISO 8601 format.
          Otherwise insert the date as Mar 04, 2014.
        "
  (interactive "P")
  (insert (format-time-string (if iso "%F" "%b %d, %Y"))))

;; -----------------------------------------------------------------------------
;; rename current buffer to the desired name. the current name is copied
;; so you can just modify it, rather than typing it from scratch
(defun anupamk:utils/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

;; -----------------------------------------------------------------------------
;; shortcut to create scratch buffers.
(defun anupamk:utils/create-new-scratch-buffer ()
  "create a new scratch buffer to work in. (could be *scratch* - *scratch-X*)"
  (interactive)
  (let ((n 0)
        bufname)
    (while (progn
             (setq bufname (concat
                            "*scratch-"
                            (int-to-string n)
                            "*"))
             (setq n (1+ n))
             (get-buffer bufname)))
    (switch-to-buffer (get-buffer-create bufname))
    (if (= n 1) initial-major-mode))) ; 1, because n was incremented

;; -----------------------------------------------------------------------------
;; hostname predicate
(defun anupamk:utils/host-name-is (host_name)
  "return true if host-name is `host_name'"
  (string-equal (system-name) host_name))

;; -----------------------------------------------------------------------------
;; running on home machine ?
(defun anupamk:utils/at-home-p ()
  (or (anupamk:utils/host-name-is "astra")
      (anupamk:utils/host-name-is "virat")))

;; -----------------------------------------------------------------------------
;; not running on home machine ?
(defun anupam:utils/not-at-home-p ()
  (not anupamk:utils/at-home-p))

;; -----------------------------------------------------------------------------
;; did vi(m) get anything right ? paren matching probably...
(defun anupamk:utils/vi-match-paren (arg)
  "Go to the matching paren if on a paren; otherwise insert %."
  (interactive "p")
  (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
        ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
        (t (self-insert-command (or arg 1)))))

;; -----------------------------------------------------------------------------
;; fill current line with '-' upto '80' columns, let the user have
;; the satisfaction of inserting a newline
(defun anupamk:utils/fill-to-end ()
  (interactive)
  (progn
    (insert-char ?- (- 80 (current-column)))))

;; -----------------------------------------------------------------------------
;; copy file name to clipboard
(defun anupamk:utils/copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

;; -----------------------------------------------------------------------------
;; toggle display of invisible characters
(defun anupamk:utils/toggle-invisibles ()
  "toggle display of invisible characters"
  (interactive)
  (if (bound-and-true-p whitespace-mode)
      (whitespace-mode -1)
    (whitespace-mode)))

;; -----------------------------------------------------------------------------
;; toggle display of line-numbers
(defun anupamk:utils/toggle-line-numbers ()
  "toggle display of line-numbers in all buffers"
  (interactive)
  (if (bound-and-true-p display-line-numbers-mode)
      (display-line-numbers-mode -1)
    (display-line-numbers-mode)))

;; -----------------------------------------------------------------------------
;; revert all buffers that are open without any confirmation, and
;; ignoring all errors. useful for those cases when you change git
;; branches and want to have the same set of buffers to be around in
;; the new branch as well.
(defun anupamk:utils/revert-all-buffers ()
  "revert all file buffers without any confirmation. buffers visiting files
    that are not readable (including those that do no longer exist) are ignored.
    other errors while reverting a buffer are reported only as messages."
  (interactive)
  (let (file)
    (dolist (buf  (buffer-list))
      (setq file  (buffer-file-name buf))
      (when (and file  (file-readable-p file))
        (with-current-buffer buf
          (with-demoted-errors "Error: %S" (revert-buffer t t)))))))

;; -----------------------------------------------------------------------------
;; bold faces are quite annoying. remove them all...
(defun anupamk:utils/unbold-all-faces ()
  "unbold all faces in emacs"
  (interactive)
  (mapc (lambda (face)
          (when (eq (face-attribute face :weight) 'bold)
            (set-face-attribute face nil :weight 'normal)))
        (face-list)))

;; -----------------------------------------------------------------------------
;; saved kbd-macro to lineup next comment seperator in a c++
;; source. this will ensure that the line
;;     '/// ----'
;; extends to the last terminating column in the source
;; file. normally, as new blocks are introduced || removed
;; etc. comment seperators don't terminate at the right column.
;;
;; for running this on the whole file, do this:
;;    C-u <some-large-number> anupamk:utils/lineup-c++-comment-seperator
(fset 'anupamk:utils/lineup-c++-comment-seperator
      (kmacro-lambda-form [?\C-s ?/ ?/ ?/ ?\C-a ?\C-s ?/ ?/ ?/ ?  ?- ?- ?- ?\C-a ?\C-k ?\M-\; ?\C-c ?e down ?\C-a ?\C-a] 0 "%d"))

;; -----------------------------------------------------------------------------
;; open file as root with sudo
(defun anupamk:utils/edit-file-with-sudo (&optional arg)
  "Edit currently visited file as root.
With a prefix ARG prompt for a file to visit.
Will also prompt for a file to visit if current
buffer is not visiting a file."
  (interactive "P")
  (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:"
                         (ido-read-file-name "Find file(as root): ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

;; -----------------------------------------------------------------------------
;; add many items to a list
(defun anupamk:utils/add-many-to-list (L &rest items)
  (dolist (item items)
    (add-to-list L item))
  (eval L))

#+end_src



* Interface and interactions
** Environment specific configuration
I am experimenting with a /radical/ approach to host/environment
specific configuration :)

Per environment configuration items (there are not that many) are
stored in separate hash tables (as attribute-value pairs). These are
then applied as and when required during emacs bootup.

First, we define a bunch of utilities for dealing with working with
the aforementioned scheme.

#+begin_src emacs-lisp

  ;; -----------------------------------------------------------------------------
  ;; this function is called to return attribute table specific to a host
  (defun anupamk:utils/get-host-attribute-table ()
    "return host specific attribute table"
    (interactive)
    (cond ((anupamk:utils/host-name-is "virat") personal-attribute-table)
          ((anupamk:utils/host-name-is "astra") personal-attribute-table)
          ((anupamk:utils/host-name-is "pnq-dev-01") tarana-attributes-table)
          ((anupamk:utils/host-name-is "aws-devel-01") tarana-attributes-table)
          ((anupamk:utils/host-name-is "mbp-01.local") personal-attribute-table)
          (t nil)))

  ;; -----------------------------------------------------------------------------
  ;; this function is called to return the value of a host-specific attribute
  (defun anupamk:utils/get-attribute-value (attr-name)
    "return value of a host-specific attribute"
    (gethash attr-name (anupamk:utils/get-host-attribute-table)))

  ;; -----------------------------------------------------------------------------
  ;; this function is called to display value of an attribute. mostly useful for
  ;; debugging.
  (defun anupamk:utils/display-attribute-value (attr-name)
    "display value of an attribute"
    (interactive)
    (message (format "attr:'%s' == '%s'" attr-name (anupamk:utils/get-attribute-value attr-name))))

#+end_src

*** Personal
This section defines personal preference for various attributes.

#+begin_src emacs-lisp

(defvar personal-attribute-table
  #s(hash-table
     size 512
     test equal
     data (
           ;; ------------------------------------------------------------------
           ;; name of this table
           "NAME"                     "personal-attribute-table"

           ;; ------------------------------------------------------------------
           ;; global keybindings via this function
           "GLOBAL-KEYBINDINGS-FUNC"  personal:setup-global-keys

           ;; ------------------------------------------------------------------
           ;; c/c++-mode configuration
           "cc-mode:c-basic-offset"           8
           "cc-mode:tab-width"                8
           "cc-mode:fill-column"              80
           "cc-mode:comment-column"           80
           "cc-mode:clangd-with-args"         ("clangd"
                                               "-j=4"
                                               "--all-scopes-completion=1"
                                               "--background-index=1"
                                               "--limit-results=128"
                                               "--cross-file-rename"
                                               "--completion-style=detailed"
                                               "--pch-storage=memory"
                                               "--log=error")
           ))
  )

#+end_src

Define global keybindings

#+begin_src emacs-lisp

  (defun personal:setup-global-keys()
    (global-set-key (kbd "C-<return>") #'anupamk:cc-utils/compile-eventually-with-make))

#+end_src

*** Work
This section contains work environment configuration items

#+begin_src emacs-lisp

(defvar tarana-attributes-table
  #s(hash-table
     size 512
     test equal
     data (
           ;; ------------------------------------------------------------------
           ;; name of this table
           "NAME"                     "tarana-attributes-table"

           ;; ------------------------------------------------------------------
           ;; global keybindings via this function
           "GLOBAL-KEYBINDINGS-FUNC"  tarana-wireless:setup-global-keys

           ;; ------------------------------------------------------------------
           ;; c/c++-mode configuration
           "cc-mode:c-basic-offset"           2
           "cc-mode:tab-width"                2
           "cc-mode:fill-column"              80
           "cc-mode:comment-column"           80
           "cc-mode:clangd-with-args"         ("/usr/bin/clangd-11"
                                               "-j=16"
                                               "--all-scopes-completion=1"
                                               "--background-index=1"
                                               "--limit-results=128"
                                               "--cross-file-rename"
                                               "--completion-style=detailed"
                                               "--pch-storage=memory"
                                               "--log=error")
           ))
  )

#+end_src

Define work specific keybindings

#+begin_src emacs-lisp

  (defun tarana-wireless:setup-global-keys()
    (global-set-key (kbd "C-<f2>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.b10.1xx")))
    (global-set-key (kbd "C-<f3>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.r10.xxx")))
    (global-set-key (kbd "C-<f4>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.p10.xx")))
    (global-set-key (kbd "C-<f5>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.h10.1xx")))
    (global-set-key (kbd "C-<f6>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.h10.2xx")))
    (global-set-key (kbd "C-<f8>") (lambda() (interactive) (anupamk:cc-utils/verify-with-bazel)))
    (global-set-key (kbd "C-<f12>") (lambda() (interactive) (anupamk:cc-utils/build-everything-with-bazel)))
    )

#+end_src

** Setup fonts

Fonts are configured using [[https://github.com/protesilaos/fontaine][fontaine]] package:

#+begin_src emacs-lisp

(straight-use-package 'fontaine)
(require 'fontaine)

;; -----------------------------------------------------------------------------
;; these are the default font heights
(setq fontaine-presets
      '((tiny
         :default-height 70)

        (small
         :default-height 80)

        (regular
         :default-height 90)

        (big
         :default-height 110)

        (large
         :default-height 120)

        (larger
         :default-height 130)

        (largest
         :default-height 140)

        ;; ---------------------------------------------------------------------
        ;; but wait...there is more !
        (humongous
         :default-height 160)

        (humongous
         :default-height 160)

        (presentation
         :default-height 200)))

;; -----------------------------------------------------------------------------
;; setup host specific *default* fontaine-presets
(add-to-list 'fontaine-presets
             (cond

              ;; virat
              ((anupamk:utils/host-name-is "virat")
               '(t
                 :default-family "PragmataPro Mono"
                 :default-weight regular
                 :default-height 90))

              ;; aws-devel-01
              ((anupamk:utils/host-name-is "aws-devel-01")
               '(t
                 :default-family "Go Mono"
                 :default-weight regular
                 :default-height 90))

              ;; mbp-01.local
              ((anupamk:utils/host-name-is "mbp-01.local")
               '(t
                 :default-family "PragmataPro Mono"
                 :default-weight regular
                 :default-height 200))

              ;; everything else
              (t
                '(t
                  :default-family "PragmataPro Mono"
                  :default-weight regular
                  :default-height 90))))

;; Recover last preset or fall back to desired style from `fontaine-presets'.
(fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular))

;; the other side of 'fontaine-restore-latest-preset
(add-hook 'kill-emacs-hook #'fontaine-store-latest-preset)

;; fontaine does not define any key bindings.  This is just a sample that
;; respects the key binding conventions.  Evaluate:
;;
;;     (info "(elisp) Key Binding Conventions")
(define-key global-map (kbd "C-c f") #'fontaine-set-preset)
(define-key global-map (kbd "C-c F") #'fontaine-set-face-font)

#+end_src

** Unbold all bold fonts everywhere

#+begin_src emacs-lisp

(add-hook 'emacs-startup-hook #'anupamk:utils/unbold-all-faces)

#+end_src

** Color theme
I /really/ love the low-contrast =zenburn= theme for long term
interactions with Emacs. Lets set that up here.

*** Zenburn

#+begin_src emacs-lisp

(use-package zenburn-theme

  :custom-face
  (diff-added    ((t :foreground "green"   :underline nil)))
  (diff-removed  ((t :foreground "red"     :underline nil)))
  (highlight     ((t :background "#a9a9a9" :underline nil)))

  :init
  ;; ---------------------------------------------------------------------------
  ;; this looks nice !
  (setq default-frame-alist '((cursor-color . "gold")))

  :config
  (load-theme 'zenburn :no-confirm)
  )

#+end_src

*** Modus Themes

From Protesilaos Stavrou

#+begin_src emacs-lisp

(use-package modus-themes
  :disabled

  :custom
  (modus-themes-italic-constructs nil)
  (modus-themes-bold-constructs nil)
  (modus-themes-region '(accented bg-only no-extend))

  :custom-face
  (diff-added    ((t :foreground "green"   :underline nil)))
  (diff-removed  ((t :foreground "red"     :underline nil)))
  (highlight     ((t :background "#a9a9a9" :underline nil)))

  :init
  ;; ---------------------------------------------------------------------------
  ;; load theme files before enabling a theme
  (modus-themes-load-themes)

  :config
  (modus-themes-load-operandi)
  )

#+end_src

** Sanitize frame look-n-feel
For each frame, we want minimal syntax highlighting, and other
miscellaneous odds and ends.

#+begin_src emacs-lisp

(defun anupamk:utils/sanitize-frame-look()
  (interactive)

  ;; ---------------------------------------------------------------------------
  ;; no bold fonts at all.
  (anupamk:utils/unbold-all-faces)

  ;; ---------------------------------------------------------------------------
  ;; not vertical / horizontal scroll bars for me
  (anupamk:utils/add-many-to-list 'default-frame-alist
                                  '(vertical-scroll-bars . nil)
                                  '(horizontal-scroll-bar-mode . nil))

  ;; ---------------------------------------------------------------------------
  ;; minimalize syntax highlighting
  (set-face-attribute 'font-lock-keyword-face nil)
  (set-face-attribute 'font-lock-type-face nil)
  (set-face-attribute 'font-lock-variable-name-face nil)
  (set-face-attribute 'font-lock-constant-face nil)
  (set-face-attribute 'font-lock-doc-face nil :inherit 'font-lock-comment-face)
  (set-face-attribute 'font-lock-preprocessor-face nil)
  (set-face-attribute 'font-lock-builtin-face nil))

;; -----------------------------------------------------------------------------
;; so, the emacs-init.el is loaded after an initial frame is
;; created. we just call this function explicitly here to ensure that
;; the default frame also has the same look-n-feel
(anupamk:utils/sanitize-frame-look)

;; -----------------------------------------------------------------------------
;; run this on all new frames that we create
(add-hook 'after-make-frame-functions (lambda (current-frame)
                                        (with-selected-frame current-frame (anupamk:utils/sanitize-frame-look))))

#+end_src

** Fringe configuration
Fringes are areas on left and right side of an Emacs frame which are
typically used to show status related feedback.

Default =8= pixel wide fringe on both sides of an Emacs frame is just
too much for my taste. I just configure it to be =6= pixels wide on
the left side of the frame, and =0= pixels wide on the right side.

#+begin_src emacs-lisp

(fringe-mode '(4 . 0))

;; -----------------------------------------------------------------------------
;; customize line continuation indicator bitmaps (with muted colors)
(define-fringe-bitmap 'left-curly-arrow [16 48 112 240 240 112 48 16])
(set-fringe-bitmap-face 'left-curly-arrow 'shadow)

(define-fringe-bitmap 'right-curly-arrow [8 12 14 15 15 14 12 8])
(set-fringe-bitmap-face 'right-curly-arrow 'shadow)

(setq-default fringes-outside-margins nil)
(setq-default indicate-buffer-boundaries nil)
(setq-default indicate-empty-lines nil)
(setq-default overflow-newline-into-fringe t)

#+end_src

** Visual feedback for common activities
We want visual feedback for common activities including (but not
limited to!) the following:

+ incremental search and query-replace highlighting
+ highlight regions when mark is active
+ hightlight current line in all windows in all modes
+ show matching parenthesis
+ this space is for rent

#+begin_src emacs-lisp

;; -----------------------------------------------------------------------------
(setq search-highlight t)
(setq query-replace-highlight t)
(setq transient-mark-mode t)

;; -----------------------------------------------------------------------------
;; enable highlighting on current line as well as current line on all windows.
(require 'hl-line)
(custom-set-variables '(global-hl-line-sticky-flag t))
(global-hl-line-mode 1)

;; -----------------------------------------------------------------------------
;; highlight matching parenthesis quickly in most unobtrusive way
;; possible, also setup the missing parenthesis highlighting as well.
(require 'paren)
(setq show-paren-style 'parenthesis)
(setq show-paren-delay 0)
(set-face-foreground 'show-paren-mismatch "orange red")
(set-face-background 'show-paren-match "black")
(set-face-foreground 'show-paren-match "gold")
(show-paren-mode t)

#+end_src

** Highlight Parentheses

#+begin_src emacs-lisp

  (use-package highlight-parentheses
    :delight
    :config
    (global-highlight-parentheses-mode))

#+end_src
** Modeline customizations

#+begin_src emacs-lisp

(use-package telephone-line
  :delight

  :init
  (telephone-line-defsegment anupamk/telephone-line-segment-clock ()
    "display current time"
    (format-time-string "[%H:%M %m/%d]"))

  ;; ---------------------------------------------------------------------------
  ;; lhs of modeline
  (setq telephone-line-lhs '((nil . (telephone-line-buffer-segment
                                     telephone-line-vc-segment
                                     telephone-line-position-segment))))

  ;; ---------------------------------------------------------------------------
  ;; rhs of modeline
  (setq telephone-line-rhs '((accent . (anupamk/telephone-line-segment-clock))))

  :hook
  (after-init . (lambda() (telephone-line-mode t))))

#+end_src


* Keyboard Configuration
** Use general.el for key bindings
=general.el= provides a better interface than f.e. =define-key=
etc. for binding keys in emacs. It is also integrated with
=use-package= which makes it all the more better.

Lets just set the basics up first, we can migrate our configuration to
it later.

#+begin_src emacs-lisp

  (use-package general)

#+end_src

** General key bindings
Years of Emacs use has resulted in some good, and some not so good
keybindings. These are all defined here.
*** Global Keys
#+begin_src emacs-lisp

(use-package emacs
  :init

  ;; ---------------------------------------------------------------------------
  ;; define a new keymap and add bindings to it
  (defvar anupamk/global-keymap (make-sparse-keymap) "keymap for anupamk/minor-keymap-mode")

  (define-minor-mode anupamk/minor-keymap-mode
    "override major mode keys with my keys"
    :init-value t
    :keymap anupamk/global-keymap)

  (define-globalized-minor-mode anupamk/global-keymap-mode anupamk/minor-keymap-mode anupamk/minor-keymap-mode)

  ;; ---------------------------------------------------------------------------
  ;; keymaps in 'emulation-mode-map-alists' take precedence
  (add-to-list 'emulation-mode-map-alists `((anupamk/minor-keymap-mode . ,anupamk/global-keymap-mode)))

  ;; ---------------------------------------------------------------------------
  ;; ofcourse we don't want these to be active in the minibuffer.
  (defun anupamk/utils:minibuffer-setup-hook ()
    (anupamk/minor-keymap-mode nil))
  (add-hook 'minibuffer-setup-hook 'anupamk/utils:minibuffer-setup-hook)

  ;; ---------------------------------------------------------------------------
  ;; assign various keys to the 'anupamk/global-keymap' here ↓

  ;; ---------------------------------------------------------------------------
  ;; recenter current line
  (define-key anupamk/global-keymap (kbd "C-c r") #'recenter)

  ;; ---------------------------------------------------------------------------
  ;; jump to begining / end of buffer
  (define-key anupamk/global-keymap (kbd "C-c <end>")  #'end-of-buffer)
  (define-key anupamk/global-keymap (kbd "C-c <home>") #'beginning-of-buffer)

  ;; ---------------------------------------------------------------------------
  ;; create a new scratch buffer
  (define-key anupamk/global-keymap (kbd "C-c s") #'anupamk:utils/create-new-scratch-buffer)

  ;; ---------------------------------------------------------------------------
  ;; rename current buffer
  (define-key anupamk/global-keymap (kbd "C-c C-x C-r") #'anupamk:utils/rename-current-buffer-file)

  ;; ---------------------------------------------------------------------------
  ;; vi style parenthesis matching
  (define-key anupamk/global-keymap (kbd "%") #'anupamk:utils/vi-match-paren)

  ;; ---------------------------------------------------------------------------
  ;; regex search always
  (define-key anupamk/global-keymap [remap isearch-forward]  #'isearch-forward-regexp)
  (define-key anupamk/global-keymap [remap isearch-backward] #'isearch-backward-regexp)

  ;; ---------------------------------------------------------------------------
  ;; visual demarcation in code
  (define-key anupamk/global-keymap (kbd "C-c e") #'anupamk:utils/fill-to-end)
  (define-key anupamk/global-keymap (kbd "C-c C-e") #'anupamk:utils/fill-to-end)

  ;; ---------------------------------------------------------------------------
  ;; <esc> to quit from a command
  (define-key anupamk/global-keymap (kbd "<escape>") #'keyboard-escape-quit)

  ;; ---------------------------------------------------------------------------
  ;; create + destroy frames
  (define-key anupamk/global-keymap (kbd "C-c C-n") #'make-frame)
  (define-key anupamk/global-keymap (kbd "C-c C-w") #'delete-frame)

  ;; ---------------------------------------------------------------------------
  ;; prevent accidental emacs-kill
  (define-key anupamk/global-keymap (kbd "C-x C-c") (lambda()
                                                      (interactive)
                                                      (message "terminate this emacs session with \'M-x kill-emacs\'")))

  ;; ---------------------------------------------------------------------------
  ;; created numbered vterm instance
  (define-key anupamk/global-keymap (kbd "C-c C-<return>") #'anupamk:utils/create-numbered-vterm-instance))

#+end_src
*** Toggle keys
#+begin_src emacs-lisp

;; -----------------------------------------------------------------------------
;; define some keybindings via the `C-x t` prefix, for toggling
;; different behaviors.
;;
;; just rolls off the tongue doesn't it ?
(use-package emacs

  :init
  (bind-keys :prefix-map toggle-map
             :prefix "C-c t"
             ("i" . anupamk:utils/toggle-invisibles)
             ("l" . anupamk:utils/toggle-line-numbers)
             ("f" . hs-toggle-hiding)
             ("t" . text-mode)
             ("R" . anupamk:utils/edit-file-with-sudo))
  )

#+end_src
** Window movement

Emacs already has =windmove= package which provides a set of routines
to for selection of windows in a frame geometrically.

Thus, for example, =windmove-left= will select a window immediately to
the left of the current selected window etc.

FWIW, =julia-assange= (yes, /that/ one) had
=change-windows-intuitively.el= which predated this !

#+begin_src emacs-lisp

(use-package emacs
  :init
  (require 'windmove)

  ;; ---------------------------------------------------------------------------
  ;; movement that falls-of-the-edge of the frame will wrap around to
  ;; find the window on the opposite side of the frame.
  (setq windmove-wrap-around t)

  :commands
  (windmove-up windmove-down windmove-left windmove-right)

  :bind
  (("C-<M-up>"    . windmove-up)
   ("C-<M-down>"  . windmove-down)
   ("C-<M-left>"  . windmove-left)
   ("C-<M-right>" . windmove-right)))

#+end_src

** Buffer movement

With =buffer-move= Emacs provides functionality for moving buffers in
various windows more easily than the usual =C-x b=.

#+begin_src emacs-lisp

(use-package buffer-move
  :delight
  :commands
  (buf-move-up buf-move-down buf-move-left buf-move-right)

  :bind
  (("C-c <C-S-up>"     . buf-move-up)
   ("C-c <C-S-down>"   . buf-move-down)
   ("C-c <C-S-left>"   . buf-move-left)
   ("C-c <C-S-right>"  . buf-move-right)))

#+end_src


* History & State
This section contains configurations for packages that record state of
various Emacs tools, f.e. minibuffer history, list of recently visited
files, window configurations etc.

** Recent files and directories
Emacs already defines a =recentf-mode= which maintains a menu for
visting files that were operated on recently.

#+begin_src emacs-lisp

(require 'recentf)
(recentf-mode t)

;; -----------------------------------------------------------------------------
;; 300 files ought to be enough for anybody (excluding some files in
;; the process)
(setq recentf-max-saved-items 300)
(setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))

#+end_src

** Window configuration
=winner-mode= is a builtin global minor mode that records the changes
in window configuration so that changes can be undone using the
=winner-undo= command.

#+begin_src emacs-lisp

  (require 'winner)
  (winner-mode t)

#+end_src

** Minibuffer history
It is positively /strange/ that saving history is not default. Let's
just enable that, and also save every possible history that we can
think of.

#+begin_src emacs-lisp

(require 'savehist)

(setq savehist-file (expand-file-name "save-hist" user-emacs-directory))

(setq kill-ring-max 1000)
(setq history-length 1000)
(setq savehist-additional-variables '(kill-ring
                                      command-history
                                      set-variable-value-history
                                      custom-variable-history
                                      query-replace-history
                                      read-expression-history
                                      minibuffer-history
                                      read-char-history
                                      face-name-history
                                      bookmark-history
                                      file-name-history))

(put 'minibuffer-history         'history-length 1000)
(put 'file-name-history          'history-length 1000)
(put 'set-variable-value-history 'history-length 1000)
(put 'custom-variable-history    'history-length 1000)
(put 'query-replace-history      'history-length 1000)
(put 'read-expression-history    'history-length 1000)
(put 'read-char-history          'history-length 1000)
(put 'face-name-history          'history-length 1000)
(put 'bookmark-history           'history-length 1000)

;; -----------------------------------------------------------------------------
;; no duplicates in history
(setq history-delete-duplicates t)

;; -----------------------------------------------------------------------------
;; start it
(let (message-log-max)
  (savehist-mode))

#+end_src

** Point
Where is the point at ?

#+begin_src emacs-lisp

(require 'saveplace)

(setq save-place-file (expand-file-name "save-point" user-emacs-directory))
(setq save-place-forget-unreadable-files t)
(save-place-mode 1)

#+end_src


* Selection candidates and search methods
** Marginalia

#+begin_src emacs-lisp

(use-package marginalia
  :general
  (:keymaps 'minibuffer-local-map
            "M-A" 'marginalias-cycle)

  :custom
  ((marginalia-align-offset -1)         ; 1 space on the right
   (marginalia-align 'right)
   (marginalia-margin-threshold 200)
   (marginalia-separator-threshold 120)
   (marginalia-truncate-width 100)
   (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))

  :init
  (marginalia-mode))

#+end_src
** Vertico

#+begin_src emacs-lisp

(use-package vertico
  :demand t
  :custom
  (vertico-count 20)
  (vertico-cycle nil)

  :general
  (:keymaps 'vertico-map
            "C-n" #'vertico-next
            "C-p" #'vertico-previous
            "C-q" #'vertico-exit)

  :config
  (vertico-mode))

#+end_src

** Orderless

#+begin_src emacs-lisp

(use-package orderless
  :demand t
  :custom
  (completion-styles '(orderless))
  (completion-category-defaults nil)
  (orderless-component-matching-styles '(orderless-regexp orderless-flex))
  (orderless-regexp-separator "[/\s_-]+")
  (completion-category-overrides '((file (styles . (partial-completion))))))

#+end_src

** Consult

#+begin_src emacs-lisp

(use-package consult

  :custom
  ((register-preview-delay 0)
   (consult-narrow-key "<"))

  :init
  ;; ---------------------------------------------------------------------------
  ;; show absolute line-numbers when narrowing is active
  (setq consult-line-numbers-widen t)

  ;; ---------------------------------------------------------------------------
  ;; setup project root for `project.el'
  (setq consult-project-root-function
        (lambda ()
          (when-let (project (project-current))
            (project-root project))))

  ;; ---------------------------------------------------------------------------
  ;; use plocate as the locate backend, ignoring case, and limiting to 100
  ;; results
  (setq consult-locate-args "plocate --ignore-case --limit 100")

  :general
  ("C-x b"   #'consult-buffer)
  ("M-g g"   #'consult-goto-line)
  )

#+end_src

** Embark
Emacs Mini Buffer Actions Rooted in Keymaps !

#+begin_src emacs-lisp

(use-package embark
  :init
  (setq prefix-help-command #'embark-prefix-help-command)

  :general
  (("C-."    . embark-act)
   ("C-;"    . embark-dwim)
   ("C-h B"  . embark-bindings))

  :config
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

#+end_src

Consult users normally want embark-consult as well.

#+begin_src emacs-lisp

(use-package embark-consult
  :after
  (embark consult)

  :demand t

  :hook
  (embark-collect . consult-preview-at-point-mode))

#+end_src

** Word lookups
*** Dictionary
Quickly lookup words in a dictionary

#+begin_src emacs-lisp

(use-package dictionary
  :commands
  (dictionary-search)

  :init
  (global-set-key (kbd "C-c d") #'dictionary-search)

  :config
  (setq dictionary-server "dict.org"))

#+end_src
*** Spelling correction
I am using [[https://github.com/redguardtoo/wucuo][wucuo]] for spell checking.

#+begin_src emacs-lisp

(use-package wucuo
  :custom
  ;; ---------------------------------------------------------------------------
  ;; just spell check the documentation regions and comments in
  ;; code. spell checking other regions seems kind of wasteful.
  ;;
  ;; would be _really_ cool to have this configured on a per
  ;; major-mode basis.
  (wucuo-font-faces-to-check '(font-lock-doc-face font-lock-comment-face))

  :init
  ;; ---------------------------------------------------------------------------
  ;; spell checking via `aspell'
  (setq ispell-program-name "aspell")
  (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US" "--run-together" "--run-together-limit=16"))

  ;; ---------------------------------------------------------------------------
  ;; disable spell checking in some major-modes
  (setq wucuo-spell-check-buffer-predicate
        (lambda ()
          (not (memq major-mode '(dired-mode
                                  log-edit-mode
                                  compilation-mode
                                  help-mode
                                  profiler-report-mode
                                  speedbar-mode
                                  gud-mode
                                  calc-mode
                                  Info-mode)))))

  :hook
  (prog-mode . wucuo-start)
  (text-mode . wucuo-start))

#+end_src

** Wgrep
With =wgrep=, we can edit the results of grep invocations and save
changes to affected buffers.

#+begin_src emacs-lisp

(use-package wgrep
  :init
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t))

#+end_src

** Isearch configuration

#+begin_src emacs-lisp

(require 'isearch)

;; -----------------------------------------------------------------------------
;; basic settings
(setq search-whitespace-regexp ".*?")
(setq search-highlight t)
(setq isearch-lax-whitespace t)
(setq isearch-regexp-lax-whitespace nil)
(setq isearch-lazy-highlight t)

;; -----------------------------------------------------------------------------
;; these are newer
(setq isearch-lazy-count t)
(setq lazy-count-prefix-format "(%s/%s) ")
(setq lazy-count-suffix-format "[%s of %s]")
(setq isearch-yank-on-move 'shift)
(setq isearch-allow-scroll 'unlimited)

#+end_src

** Ripgrep
RipGrep is a wrapper over the versatile and /fast/ ripgrep command
line tool. It allows us to interactively create searches, performing
automatic searches based on editing context, refining and modifying
search results, specifying custom query commands etc. etc.

#+begin_src emacs-lisp

(use-package rg
  :after
  (wgrep)

  :custom
  ;; ---------------------------------------------------------------------------
  ;; group matches in same file together
  (rg-group-result t)

  ;; ---------------------------------------------------------------------------
  ;; hide most of rg command line when non nil
  (rg-hide-command t)

  ;; ---------------------------------------------------------------------------
  ;; show the columns of matches in the output buffer
  (rg-show-columns nil)

  ;; ---------------------------------------------------------------------------
  ;; show headers in the result
  (rg-show-header t)

  ;; ---------------------------------------------------------------------------
  ;; file aliases added to the 'rg' built-in aliases
  (rg-custom-type-aliases nil)

  ;; ---------------------------------------------------------------------------
  ;; default file alias to use when no alias can be determined
  (rg-default-alias-fallback "all")

  :config
  ;; ---------------------------------------------------------------------------
  ;; ripgrep in project root
  (rg-define-search anupamk:ripgrep-search/rg-vc-or-dir
    "ripgrep in project-root or $pwd"
    :query ask
    :format regexp
    :files "everything"

    ;; -------------------------------------------------------------------------
    ;; smart setting will trigger an analyze of the
    ;; search string and if it’s all lower case, the
    ;; search will be case insensitive, otherwise it
    ;; will be case sensitive
    :rg-ignore-case smart

    ;; -------------------------------------------------------------------------
    ;; select a root-search directory. project-root or
    ;; current directory
    :dir (let ((vc (vc-root-dir)))
           (if vc
               vc
             default-directory))

    ;; -------------------------------------------------------------------------
    ;; specifies if the final search command line can
    ;; be modified and confirmed by the user.
    :confirm prefix
    :flags ("--no-hidden -g '!*.patch' -g '!*.patch.*' -g '!*.savehist'"))

  ;; ---------------------------------------------------------------------------
  ;; ripgrep for symbol at point in $PWD
  (rg-define-search anupamk:ripgrep-search/rg-ref-in-pwd
    "ripgrep for symbol at point in $pwd"
    :query ask
    :format regexp
    :files "everything"

    ;; -------------------------------------------------------------------------
    ;; smart setting will trigger an analyze of the
    ;; search string and if it’s all lower case, the
    ;; search will be case insensitive, otherwise it
    ;; will be case sensitive
    :rg-ignore-case smart

    :dir default-directory
    :confirm prefix
    :flags ("--no-hidden -g '!*.patch' -g '!*.patch.*' -g '!*.savehist'"))


  (defun anupamk:ripgrep-search/save-search-as-name ()
    "Save `rg' buffer, naming it after the current search query.
          This function is meant to be mapped to a key in `rg-mode-map'."
    (interactive)
    (let ((pattern (car rg-pattern-history)))
      (rg-save-search-as-name (concat "≪" pattern "≫"))))

  :bind
  (("M-s r" . anupamk:ripgrep-search/rg-vc-or-dir)
   ("M-s d" . anupamk:ripgrep-search/rg-ref-in-pwd)))

#+end_src




* Application and utilities
** Which Key
This is a minor mode for Emacs that displays the key bindings following your
currently entered incomplete command.

#+begin_src emacs-lisp

(use-package which-key
  :commands

  (which-key-C-h-dispatch)

  :config
  (setq which-key-show-early-on-C-h t)
  (setq which-key-idle-delay 10000)
  (setq which-key-idle-secondary-delay 0.05)
  (setq which-key-popup-type 'side-window)
  (setq which-key-show-prefix 'echo)
  (setq which-key-max-display-columns 6)
  (setq which-key-separator " ")
  (setq which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL"))

  :hook
  (after-init . which-key-mode))

#+end_src
** Dynamic word completion
I have /graduated/ from using =dabbrev-expand= to
=hippie-expand=. It looks at the word before point and tries to expand
it in various ways including expanding from a fixed list, expand from
matching text found in the buffer or others.

What does it have to do with hippies ? No idea.

#+begin_src emacs-lisp

(require 'hippie-exp)
(global-set-key (kbd "M-/") #'hippie-expand)

(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))

#+end_src

** Uniquify file names in buffers

#+begin_src emacs-lisp

;; -----------------------------------------------------------------------------
;; forward                       bar/mumble/name    quux/mumble/name
;; reverse                       name\mumble\bar    name\mumble\quux
;; post-forward                  name|bar/mumble    name|quux/mumble
;; post-forward-angle-brackets   name<bar/mumble>   name<quux/mumble>
;; nil                           name               name<2>
(setf uniquify-buffer-name-style 'post-forward-angle-brackets)

#+end_src
** Auto revert

#+begin_src emacs-lisp

(require 'autorevert)

;; -----------------------------------------------------------------------------
;; enable globally
(global-auto-revert-mode)

;; -----------------------------------------------------------------------------
;; don't announce when a buffer is reverted
(setq-default auto-revert-verbose nil)

;; -----------------------------------------------------------------------------
;; also auto refresh dired buffers
(setq global-auto-revert-non-file-buffers t)

#+end_src

** Version control
*** Magit

#+begin_src emacs-lisp

(use-package magit
  :delight
  :demand t
  :config

  ;; ---------------------------------------------------------------------------
  ;; whether to show word-granularity differences within diff hunks
  (setq magit-diff-refine-hunk t)

  ;; ---------------------------------------------------------------------------
  ;; move untracked files section behind Unstaged changes section
  (magit-add-section-hook 'magit-status-sections-hook
                          'magit-insert-untracked-files
                          'magit-insert-unpushed-commits t)

  (remove-hook 'git-commit-finish-query-functions
               'git-commit-check-style-conventions)

  ;; ---------------------------------------------------------------------------
  ;; 'stuff' to-do before magit-status, for now, just unbold all faces :o)
  (defadvice magit-status (around anupamk/magit-status-pre activate)
    ad-do-it
    (anupamk:utils/unbold-all-faces))

  :bind  (("C-c g" . magit-status)
          ("C-c l" . magit-log)
          ("C-h B" . magit-blame)))

#+end_src

*** Git Gutter in Emacs
These are indicators in fringe that show uncomitted
added/deleted/modified blocks in a buffer.

#+begin_src emacs-lisp

(use-package git-gutter)
(use-package git-gutter-fringe)

;; -----------------------------------------------------------------------------
;; lets just set it up for all files in a git repository
(require 'git-gutter-fringe)
(global-git-gutter-mode t)

;; -----------------------------------------------------------------------------
;; setup the bitmap for appearance
(when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'git-gutter-fr:added [255 255 255 255 255
                                                      255 255 255 255
                                                      255 255 255 255
                                                      255 255 255 255
                                                      255 255 255 255
                                                      255 255 255 255] nil nil '(center t))

       (define-fringe-bitmap 'git-gutter-fr:modified [255 255 255 255 255
                                                          255 255 255 255
                                                          255 255 255 255
                                                          255 255 255 255
                                                          255 255 255 255
                                                          255 255 255 255] nil nil '(center t))

       (define-fringe-bitmap 'git-gutter-fr:deleted [255 255 255 255 255
                                                       255 255 255 255
                                                       255 255 255 255
                                                       255 255
                                                       255 255
                                                       255] nil nil '(center t)))

;; -----------------------------------------------------------------------------
;; interval (in seconds) for updating diff information.
;;
;; the default is '0' which results in updating the gutter only on
;; file save.
(setq git-gutter:update-interval 0.02)

#+end_src

** Bookmark places in buffer

#+begin_src emacs-lisp

(use-package bookmark
  :delight

  :functions
  (anupamk:bookmark/quick-save-bookmark)

  :config
  (defun anupamk:bookmark/quick-save-bookmark ()
    "Save bookmark with name as 'buffer:row:col'"
    (interactive)
    (bookmark-set (format "%s:%s:line %s:column %s"
                          (thing-at-point 'symbol)
                          (buffer-name)
                          (line-number-at-pos)
                          (current-column)))
    (message "Bookmarked saved at current position"))

  (setq bookmark-save-flag t)

  :bind
  (("C-c q s b" . anupamk:bookmark/quick-save-bookmark)))

#+end_src
** Collection of Ridiculously Useful eXtensions

#+begin_src emacs-lisp

(use-package crux
  :bind
  (("C-a" . crux-move-beginning-of-line)))

#+end_src
** VTerm
VTerm is an fast and full fledged terminal emulator within Emacs. Built as a
dynamic module on top of libvterm, it provides an overall better experience
as compared to alternatives f.e. =ansi-term=.

#+begin_src emacs-lisp

(use-package vterm
  :custom
  ;; ---------------------------------------------------------------------------
  ;; ignore bold text properties
  (vterm-disable-bold t)

  ;; ---------------------------------------------------------------------------
  ;; ignore underline text properties
  (vterm-disable-underline t)

  ;; ---------------------------------------------------------------------------
  ;; ignore inverse-video text properties
  (vterm-disable-inverse-video t)

  ;; ---------------------------------------------------------------------------
  ;; how big should the scrollback buffer be ?
  (vterm-max-scrollback 10000)

  ;; ---------------------------------------------------------------------------
  ;; Controls whether or not to exclude the prompt when copying a line
  ;; in vterm-copy-mode
  (vterm-copy-exclude-prompt t)

  :config
  ;; ---------------------------------------------------------------------------
  ;; open a terminal in the current project
  (defun anupamk:term/spawn-vterm-in-project ()
    "Spawn a vterm in the current project."
    (interactive)
    (let* ((project-current (project-current))
           (default-directory (if project-current
                                  (project-root project-current)
                                default-directory)))
      (vterm))))

#+end_src
** Code folding

Code folding enables hiding and showing blocks of text in different buffers.
Built in =hideshow= mode makes this quite a seamless experience.

#+begin_src emacs-lisp

  (add-hook 'prog-mode-hook #'hs-minor-mode)

#+end_src
** PDF Tools

#+begin_src emacs-lisp

(use-package pdf-tools

  ;; ---------------------------------------------------------------------------
  ;; only iff running on home setup
  :if (anupamk:utils/at-home-p)

  :defer
  :init
  (pdf-tools-install)

  :general
  (:keymaps 'pdf-view-mode-map
            "C-s" 'isearch-forward)

  :custom
  (pdf-annot-activate-created-annotations t)
  )

#+end_src
** Completion

#+begin_src emacs-lisp

(use-package company
  :ensure t
  :defer t

  :custom
  ;; ---------------------------------------------------------------------------
  ;; Search other buffers with the same modes for completion instead
  ;; of searching all other buffers.
  (company-dabbrev-other-buffers t)
  (company-dabbrev-code-other-buffers t)

  ;; ---------------------------------------------------------------------------
  ;; M-<num> to select an option according to its number.
  (company-show-numbers t)

  ;; ---------------------------------------------------------------------------
  ;; Only 2 letters required for completion to activate.
  (company-minimum-prefix-length 3)

  ;; ---------------------------------------------------------------------------
  ;; Do not downcase completions by default.
  (company-dabbrev-downcase nil)

  ;; ---------------------------------------------------------------------------
  ;; Even if I write something with the wrong case, provide the correct casing.
  (company-dabbrev-ignore-case t)

  ;; ---------------------------------------------------------------------------
  ;; company completion wait
  (company-idle-delay 0.2)

  ;; ---------------------------------------------------------------------------
  ;; No company-mode in shell & eshell
  (company-global-modes '(not eshell-mode shell-mode))

  ;; ---------------------------------------------------------------------------
  ;; for both text and programming modes.
  :hook
  ((text-mode . company-mode)
   (prog-mode . company-mode)))

#+end_src

* Window Management
The association list in =display-buffer-alist= describes the rule-set
for controlling the display of windows within an Emacs frame.

The general idea is to display buffers of a specific group or type in
a specific location for a smoother aka low-friction end-to-end
experience.

#+begin_src emacs-lisp

;; -----------------------------------------------------------------------------
;; override, display-buffer-alist to better manage appearance of popup
;; windows in an emacs-frame.
(use-package emacs
  :custom
  (display-buffer-alist
   '(
     ;; ------------------------------------------------------------------------
     ;; left-side window configuration

     ;; ------------------------------------------------------------------------
     ;; right-side window configuration

     ;; ------------------------------------------------------------------------
     ;; magit and related windows
     ("\\magit.*"
      (display-buffer-in-side-window)
      (dedicated . nil)
      (window-width . 0.50)
      (side . right)
      (slot . 0)
      (window-parameters . ((mode-line-format . (" "
                                                 mode-line-buffer-identification)))))

     ("\\*\\(Help\\|Faces\\|Colors\\|Apropos\\).*"
      (display-buffer-in-side-window)
      (window-width . 0.40)
      (side . right)
      (slot . 0)
      (window-parameters . ((mode-line-format . (" "
                                                 mode-line-buffer-identification)))))

     ;; ------------------------------------------------------------------------
     ;; top-side window configuration

     ;; ------------------------------------------------------------------------
     ;; bottom-side window configuration

     ;; ------------------------------------------------------------------------
     ;; magit stash
     ("\\*~stash.*"
      (display-buffer-in-side-window)
      (window-width . 0.50)
      (side . bottom)
      (slot . 0)
      (window-parameters . ((mode-line-format . (" "
                                                 mode-line-buffer-identification)))))

     ;; ------------------------------------------------------------------------
     ;; code searches via ripgrep, xref etc.
     ("\\*\\(rg\\|xref\\).*"
      (display-buffer-in-side-window)
      (window-width . 0.50)
      (side . bottom)
      (slot . 0)
      (window-parameters . ((mode-line-format . (" "
                                                 mode-line-buffer-identification)))))

     ;; ------------------------------------------------------------------------
     ;; bottom-side window (right of `rg' ∵ 'slot == 1')
     ("\\*compilation*"
      (display-buffer-in-side-window)
      (window-width . 0.30)
      (side . bottom)
      (slot . 1)
      (window-parameters . ((mode-line-format . (" "
                                                 mode-line-buffer-identification)))))

     ;; ------------------------------------------------------------------------
     ;; this is the Emacs byte compilation
     ("\\*\\(Compile-Log\\).*"
      (display-buffer-in-side-window)
      (window-width . 0.20)
      (dedicated . t)
      (side . bottom)
      (slot . 0)
      (window-parameters . ((mode-line-format . (" "
                                                 mode-line-buffer-identification)))))
     ))

  (even-window-sizes 'height-only)

  :hook
  ((help-mode . visual-line-mode)
   (custom-mode . visual-line-mode))
  )

(use-package emacs
  :functions (anupamk:window-utils/display-buffer-at-bottom)

  :config

  ;; ---------------------------------------------------------------------------
  ;; move current buffer to bottom of the frame.
  (defun anupamk:window-utils/display-buffer-at-bottom ()
    "move current buffer to the bottom of the frame. this is useful to take a
              buffer out of a side window."
    (interactive)
    (let ((buffer (current-buffer)))
      (with-current-buffer buffer
        (delete-window)
        (display-buffer-at-bottom buffer `((window-parameters . ((mode-line-format . (" "
                                                                                      mode-line-buffer-identification)))))))))

  :bind
  (("C-c b" . anupamk:window-utils/display-buffer-at-bottom))

  )

#+end_src



* Programming
This section is all about configuring packages that deal with
programming languages and 'stuff'.

** Project Configuration

Since about version =25= or thereabouts, Emacs introduced native
project management via =project.el=. The built in LSP client =eglot=
use that for its interactions.

Lets set that up.

#+begin_src emacs-lisp

(use-package emacs
  :init

  :functions
  (anupamk:project-utils/locate-project-root
   anupamk:project-utils/do-locate-project-root)

  :config
  ;; ---------------------------------------------------------------------------
  ;; find project root-dir by searching (recursively) through a list of
  ;; project-root-markers.
  (defun anupamk:project-utils/do-locate-project-root (dirname all-marker-lists)
    "find project root directory (starting from DIRNAME) by searching
       for markers defined in ALL-MARKER-LISTS"

    (when all-marker-lists
      (let ((anupamk:project-root (locate-dominating-file dirname (car all-marker-lists))))
        (if (not anupamk:project-root)
            ;; -----------------------------------------------------------------
            ;; keep looking ...
            (anupamk:project-utils/do-locate-project-root dirname (cdr all-marker-lists))

          ;; -------------------------------------------------------------------
          ;; we got a live one
          (cons 'vc anupamk:project-root)))))

  ;; ---------------------------------------------------------------------------
  ;; just a wrapper over the real thaang
  (defun anupamk:project-utils/locate-project-root (dirname)
    (let ((project-root-markers (list "Cargo.toml"
                                      "WORKSPACE"
                                      "compile_commands.json"
                                      "compile_flags.txt"
                                      ".git")))
      (anupamk:project-utils/do-locate-project-root dirname project-root-markers)))

  :bind
  (("C-c p f" . project-find-file)
   ("C-c p r" . project-find-regexp))

  :hook
  (project-find-functions #'anupamk:project-utils/locate-project-root))

#+end_src

** Programming Languages
*** CMake

#+begin_src emacs-lisp

(use-package cmake-mode
  :config
  (add-to-list 'auto-mode-alist '("\\CMakeLists.txt\\'" . cmake-mode)))

#+end_src

*** Generic
Enable auto-fill for comments in =prog-mode= buffers

#+begin_src emacs-lisp

;; -----------------------------------------------------------------------------
;; auto fill comments in programming modes only
(defun anupamk:utils/auto-fill-comments ()
  "comments in programming mode are automatically filled"
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode))

(add-hook 'prog-mode-hook #'anupamk:utils/auto-fill-comments)

#+end_src

*** Eglot LSP client
Although =lsp-mode= has been in existence for a while, I prefer
=eglot= because

+ almost /zero-touch/ provisioning and
+ built into Emacs, and positively /spartan/ (yes, that is a /virtue/)

Lets set that up...but before we do that, we need to ensure that the
latest version of =flymake= is installed. This is best documented
[[https://github.com/radian-software/straight.el#the-wrong-version-of-my-package-was-loaded][here]].

#+begin_src emacs-lisp

(straight-use-package 'flymake)

#+end_src

#+begin_src emacs-lisp

;; -----------------------------------------------------------------------------
;; don't allow long eldoc strings to resize echo area display
(setq eldoc-echo-area-use-multiline-p nil)

(use-package eglot
  :ensure t
  :demand t
  :config

  ;; ---------------------------------------------------------------------------
  ;; disable annoying, _distracting_, over-the-top features that serve
  ;; no useful purpose at all (imnsho)
  (setq eglot-ignored-server-capabilities '(:documentHighlightProvider    ; highlight symbols automatically
                                            :documentSymbolProvider       ; list symbols in a buffer
                                            :hoverProvider                ; documentation on hover
                                            :signatureHelpProvider        ; function-signature help
                                            ))

  :bind
  (:map eglot-mode-map
              ("C-c l a" . eglot-code-actions)
              ("C-c l r" . eglot-rename)
              ("C-c l f" . eglot-format)
              ("C-c l d" . eldoc))
  )

#+end_src

*** C/C++
**** Utility functions

Define some utility functions for working with c/c++ sources.

#+begin_src emacs-lisp

(use-package emacs
  :functions
  (anupamk:cc-utils/compile-eventually
   anupamk:cc-utils/compile-eventually-with-make
   anupamk:cc-utils/compile-eventually-with-bazel
   anupamk:cc-utils/verify-with-bazel
   anupamk:cc-utils/build-everything-with-bazel
   anupamk:cc-utils/quick-compile-cmdstr)

  :config
  (defun anupamk:cc-utils/compile-eventually (search-fname compile-cmdstr)
    "recursively search up the directory tree for 'search-file-name',
        and when found, run 'compile-cmdstr'"

    ;; find the root of the development-tree
    (defvar search-root-dir (file-name-directory buffer-file-name))
    (defvar devel-root-dir (locate-dominating-file search-root-dir search-fname))

    ;; do the build
    (if devel-root-dir (with-temp-buffer (cd devel-root-dir)
                                         (compile compile-cmdstr))
      (progn  (message (concat "unable to find: '"
                               search-fname "' within: '"
                               search-root-dir "', running quick-compile"))
              (compile (anupamk:cc-utils/quick-compile-cmdstr)))))

  ;; ---------------------------------------------------------------------------
  ;; compile with a makefile
  (defun anupamk:cc-utils/compile-eventually-with-make ()
    "compile with make"
    (interactive)
    (anupamk:cc-utils/compile-eventually "Makefile" "make"))

  ;; ---------------------------------------------------------------------------
  ;; compile with bazel
  (defun anupamk:cc-utils/compile-eventually-with-bazel(target)
    "compile with bazel"
    (interactive)
    (let ((bazel-compile-cmdstr (concat "set -e ; time t3 build --gen-compile-commands -c " target " | cut -c26-")))
      (anupamk:cc-utils/compile-eventually "bazel_build_defs" bazel-compile-cmdstr)))

  ;; ---------------------------------------------------------------------------
  ;; test with bazel
  (defun anupamk:cc-utils/verify-with-bazel ()
    "test with bazel"
    (interactive)
    (let ((bazel-test-cmdstr (concat "t3 verify | cut -c26-")))
      (anupamk:cc-utils/compile-eventually "bazel_build_defs" bazel-test-cmdstr)))

  ;; ---------------------------------------------------------------------------
  ;; test with bazel
  (defun anupamk:cc-utils/build-everything-with-bazel ()
    "test with bazel"
    (interactive)
    (let ((bazel-test-cmdstr (concat "t3 build | cut -c26-")))
      (anupamk:cc-utils/compile-eventually "bazel_build_defs" bazel-test-cmdstr)))

  ;; ---------------------------------------------------------------------------
  ;; quickly compile single source c/c++ programs. it produces final
  ;; executable in the 'obj' sub-directory. the executable is called
  ;; `file-name' without the extension
  ;;
  ;; this, a file called `<some-path>/foo.cpp' will produce an
  ;; executable called `<some-path>/obj/foo'
  (defun anupamk:cc-utils/quick-compile-cmdstr()
    "quick compile single-file c/c++ programs"

    ;; -------------------------------------------------------------------------
    ;; how we build c/c++ sources are almost fixed
    ;;     -fdiagnostics-color=never ==> no ansii colorized output
    (defvar qc-cmd-prefix:c   "gcc -fdiagnostics-color=never -std=c99 -g -O2 -Wall -o obj/")
    (defvar qc-cmd-prefix:cpp "g++ -fdiagnostics-color=never -std=c++20 -g -O2 -Wall -o obj/")

    ;; first setup the appropriate compilation command based on buffer
    ;; major-mode
    (setq-local compile-command (format "%s%s %s"
                                        ;; %s: 'qc-cmd-prefix:{c,cpp}'
                                        (if (eq major-mode 'c-mode)
                                            qc-cmd-prefix:c
                                          qc-cmd-prefix:cpp)

                                        ;; %s: 'obj/<file-name>'
                                        (file-name-nondirectory (file-name-sans-extension (buffer-file-name)))

                                        ;; %s: '<file-name>.{c,cpp}'
                                        (file-name-nondirectory (buffer-file-name)))))
  )

#+end_src

**** Configuration

#+begin_src emacs-lisp

(use-package eglot
  :hook
  (c-mode . eglot-ensure)
  (c++-mode . eglot-ensure))

(use-package clang-format+
  )

(use-package cc-mode
  :demand t
  :functions (anupamk:cc/c-mode-common-hook
              anupamk:cc/c++-mode-hook
              anupamk:cc/c-mode-hook)

  :init

  (defconst cc-lang-server-cmdline (anupamk:utils/get-attribute-value "cc-mode:clangd-with-args"))

  :config

  (defun anupamk:cc/c-mode-common-hook ()
    (message "loading c-mode-common customizations")

    ;; -------------------------------------------------------------------------
    ;; highlight parenthesis
    (highlight-parentheses-mode t)

    ;; -------------------------------------------------------------------------
    ;; '_' is not a modifier anymore
    (modify-syntax-entry ?_ "w")

    ;; -------------------------------------------------------------------------
    ;;  any specific code-fmt'ing related changes
    (setq c-basic-offset (anupamk:utils/get-attribute-value "cc-mode:c-basic-offset")

          ;; -------------------------------------------------------------------
          ;; Distance between tab stops (for display of tab
          ;; characters), in columns.
          tab-width (anupamk:utils/get-attribute-value "cc-mode:tab-width")

          ;; -------------------------------------------------------------------
          ;; spaces instead of tabs :)
          indent-tabs-mode nil

          ;; -------------------------------------------------------------------
          ;; column beyond which automatic line-wrapping should
          ;; happen.
          fill-column (anupamk:utils/get-attribute-value "cc-mode:fill-column")

          ;; -------------------------------------------------------------------
          ;; column to indent right-margin comments to...
          comment-column (anupamk:utils/get-attribute-value "cc-mode:comment-column")

          ;; -------------------------------------------------------------------
          ;; Specifies how M-x indent-for-comment should handle
          ;; comment-only lines. When this variable is non-nil,
          ;; comment-only lines are indented according to syntactic
          ;; analysis via `c-offsets-alist'. Otherwise, the comment is
          ;; indented as if it was preceded by code. Note that this
          ;; variable does not affect how the normal line indentation
          ;; treats comment-only lines.
          c-indent-comments-syntactically-p t)

    ;; -------------------------------------------------------------------------
    ;; syntax help
    ;;  +   c-basic-offset times 1
    ;;  -   c-basic-offset times -1
    ;;  ++  c-basic-offset times 2
    ;;  --  c-basic-offset times -2
    ;;  *   c-basic-offset times 0.5
    ;;  /   c-basic-offset times -0.5
    (c-set-offset 'case-label '+)
    (c-set-offset 'access-label '/)
    (c-set-offset 'label '/)

    ;; -------------------------------------------------------------------------
    ;; set the file mode to clang-format+-mode so that clang-format is
    ;; used for formatting all c/c++ sources
    (clang-format+-mode t)

    ;; -------------------------------------------------------------------------
    ;; abbrev and subword modes are quite useful, enable those as well
    (abbrev-mode t)
    (subword-mode t)
    )

  ;; ---------------------------------------------------------------------------
  ;; c++ mode customizations
  (defun anupamk:cc/c++-mode-hook ()
    (anupamk:cc/c-mode-common-hook)
    (message "loading c++-mode customizations")
    (setq comment-start "///")
    (setq comment-end "")

    ;; -------------------------------------------------------------------------
    ;; setup eglot with c++ mode
    (add-to-list 'eglot-server-programs `(c++-mode . ,cc-lang-server-cmdline))
    )

  ;; ---------------------------------------------------------------------------
  ;; c-mode customizations
  (defun anupamk:cc/c-mode-hook ()
    (anupamk:cc/c-mode-common-hook)
    (message "loading c-mode customizations")

    ;; -------------------------------------------------------------------------
    ;; setup eglot with c++ mode
    (add-to-list 'eglot-server-programs `(c-mode . ,cc-lang-server-cmdline))
    )

  ;; ---------------------------------------------------------------------------
  ;; setup canonical styles
  (anupamk:utils/add-many-to-list 'c-default-style

                                  ;; -------------------------------------------
                                  ;; for c-mode files
                                  '(c-mode . "k&r")

                                  ;; -------------------------------------------
                                  ;; for c++-mode files
                                  '(c++-mode . "Stroustrup"))

  ;; ---------------------------------------------------------------------------
  ;; some useful bindings
  (define-key c-mode-map (kbd "RET")  #'newline-and-indent)
  (define-key c-mode-map (kbd "C-<ret>") #'recompile)

  ;; ---------------------------------------------------------------------------
  ;; jump directly to source when we see compilation errors
  (add-to-list 'compilation-search-path (getenv "PWD"))

  :hook
  (c-mode . anupamk:cc/c-mode-hook)
  (c++-mode . anupamk:cc/c++-mode-hook)
  )

#+end_src

Also apply host specific keybindings

#+begin_src emacs-lisp

  ;; ---------------------------------------------------------------------------
  ;; host specific keybindings
  (funcall (anupamk:utils/get-attribute-value "GLOBAL-KEYBINDINGS-FUNC"))

#+end_src

*** Java (yuck !)
Pretty vanilla configuration

#+begin_src emacs-lisp

(defun anupamk:java-mode-setup()
  "setup java mode"
  (interactive)

  ;; ---------------------------------------------------------------------------
  ;; basic settings
  (setq c-basic-offset 4)
  (setq tab-width 4)
  (setq indent-tabs-mode nil)

  ;; ---------------------------------------------------------------------------
  ;; comments
  (setq comment-start "///")
  (setq comment-end ""))

(add-hook 'java-mode-hook #'anupamk:java-mode-setup)

#+end_src

*** Scheme
Using =racket-mode= for programming in scheme.

#+begin_src emacs-lisp

(use-package racket-mode
  :mode
  ("\\.rkt\\'" . racket-mode)

  :config
  (racket-add-back-end "/home/anupam/source-code/sicp/racket"
                       :racket-program "/usr/bin/racket")

  :general
  (:keymaps 'racket-mode-map
            "<f7>" #'racket-run)
  )

#+end_src

*** Python

+ The default package =python.el= provides =python-mode= which is the
major-mode for python.

#+begin_src emacs-lisp

(use-package python
  :straight (:type built-in)

  :config

  ;; ---------------------------------------------------------------------------
  ;; remove guess indent python message
  (setq python-indent-guess-indent-offset-verbose nil)

  :custom
  (python-shell-interpreter "ipython")
  (python-shell-interpreter-args "-i --simple-prompt")
  (python-indent-guess-indent-offset-verbose nil)

  :bind
  ( :map python-mode-map
    ("C-c r" . python-indent-shift-right)
    ("C-c l" . python-indent-shift-left))

  )

#+end_src

+ For inferior python processes hide the modeline.

#+begin_src emacs-lisp

(use-package hide-mode-line
  :ensure t
  :defer t

  :hook
  (inferior-python-mode . hide-mode-line-mode))

#+end_src

+ I use poetry to manage python environments, let's set that up.

#+begin_src emacs-lisp

(use-package poetry
  :ensure t
  :defer t

  :config
  ;; ---------------------------------------------------------------------------
  ;; checks for the correct virtualenv, which is a better strategy
  ;; because the default one is quite slow
  (setq poetry-tracking-strategy 'switch-buffer)

  :hook
  (python-mode . poetry-tracking-mode))

#+end_src

+ Formatting python buffers is under the aegis of [[https://github.com/psf/black][black]].

#+begin_src emacs-lisp

(use-package blacken
  :ensure t
  :defer t

  :commands blacken-mode blacken-buffer

  :custom
  (blacken-allow-py36 t)
  (blacken-skip-string-normalization t)

  :hook
  (python-mode-hook . blacken-mode))

#+end_src

+ Use numpy style docstrings for python.

#+begin_src emacs-lisp

(use-package numpydoc
  :ensure t
  :defer t

  :custom
  (numpydoc-insert-examples-block nil)
  (numpydoc-template-long nil)

  :bind
  (:map python-mode-map  ("C-c C-n" . numpydoc-generate)))

#+end_src

+ And ofcourse, all of this integrated with eglot

#+begin_src emacs-lisp

(use-package eglot

  :config
  ;; ---------------------------------------------------------------------------
  ;; install pyright (as root) with
  ;;    'npm install -g pyright'
  (add-to-list 'eglot-server-programs '(python-mode . ("pyright-langserver" "--stdio")))

  :hook
  (python-mode . eglot-ensure))

#+end_src

** Building
*** Compilation buffer configuration

#+begin_src emacs-lisp

(setq compilation-scroll-output 'first-error ; Scroll but stop at first error.
      compilation-skip-threshold 2           ; Skip anything less than errors.
      compilation-always-kill t)             ; Don't ask, just start new compilation.

;; -----------------------------------------------------------------------------
;; setup compilation buffer
(defun anupamk:utils/setup-compilation-buffer()
  ;; ---------------------------------------------------------------------------
  ;; Turn off adaptive process buffering when using compilation
  ;; mode, which allows Emacs to read subprocess output in larger
  ;; chunks.
  ;;
  ;; also see `v:read-process-output-max' for more information
  (setq process-adaptive-read-buffering nil)
  )

(add-hook 'compilation-mode-hook #'anupamk:utils/setup-compilation-buffer)

;; -----------------------------------------------------------------------------
;; Turn it back on again when finished.
(add-hook 'compilation-finish-functions
          (lambda (buffer string)
            (setq process-adaptive-read-buffering t)))

#+end_src


* Org mode configuration
** Preliminaries
While editing code blocks in org-mode buffers, we want =<tab>= to
indent natively. Moreover, in org-mode buffers we want a =visual-line=
which allows word-wrap etc. to happen on =visual= lines rather than
=logical= lines.

#+begin_src emacs-lisp

(defun anupamk/do-org-mode-setup ()
  "run these commands every time an org-mode buffer starts up"

  ;; ---------------------------------------------------------------------------
  ;; highlight parenthesis
  (highlight-parentheses-mode t)

  ;; ---------------------------------------------------------------------------
  ;; indent text according to outline structure
  (org-indent-mode)

  ;; ---------------------------------------------------------------------------
  ;; code-blocks within org-mode
  (setq org-src-window-setup 'current-window)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-edit-src-content-indentation 0)

  ;; ---------------------------------------------------------------------------
  ;; fontify natively
  (setq org-src-fontify-natively t)

  ;; ---------------------------------------------------------------------------
  ;; fancy html5 generation
  (setq org-html-html5-fancy t)
  (setq org-html-doctype "html5")

  ;; ---------------------------------------------------------------------------
  ;; auto-filling in org-mode buffers
  (auto-fill-mode)

  ;; ---------------------------------------------------------------------------
  ;; when `visual-line-mode' is enabled, word-wrap is turned on, and
  ;; simple editing commands are redefined to act on visual lines, not
  ;; logical lines.
  (visual-line-mode 1))

(add-hook 'org-mode-hook #'anupamk/do-org-mode-setup)

#+end_src

** Easy addition of source blocks
Since version 9.2, org-mode has moved to a new mechanism called
/structured-template/. Which makes it a bit harder to add source-code
blocks.

Bring the old easy templating system back via =org-tempo= and minor
tweaks. With this configuration I can now say =<el[TAB]= which expands
into the familiar =#+begin_src emacs-lisp ... +end_src= block.

#+begin_src emacs-lisp

(require 'org-tempo)

;; -----------------------------------------------------------------------------
;; easy addition of source-code blocks in org documents
(anupamk:utils/add-many-to-list 'org-structure-template-alist
                                ;; ---------------------------------------------
                                ;; shell-scripts
                                '("sh" . "src shell")

                                ;; ---------------------------------------------
                                ;; emacs-lisp
                                '("el"   . "src emacs-lisp")

                                ;; ---------------------------------------------
                                ;; python
                                '("py"   . "src python"))
#+end_src

** Roam

Org-Roam is a system note-taking which can be linked together creating
a =network knowledge base=. It is inspired by a program called =roam=
and a note taking  strategy called =Zettlekasten=, also called a
=second brain=.

#+begin_src emacs-lisp

(use-package org-roam
  :init

  ;; ---------------------------------------------------------------------------
  ;; don't display the annoying warning message about upgrading
  ;; org-roam to v2. because it needs to be defined _before_ package
  ;; is loaded, we do this in the `init' section of the config.
  (setq org-roam-v2-ack t)

  :custom
  (org-roam-directory "~/source-code/roam-notes")
  (org-roam-completion-everywhere t)

  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)

         :map org-mode-map
         ("C-M-i" . completion-at-point))

  :config
  (org-roam-db-autosync-enable))

#+end_src


* End Of Configuration

All of our configuration is now loaded, let the games begin.

#+begin_src emacs-lisp

(defun greet-post-startup-complete ()
  (message "All configuration is now loaded, have a lot of fun !"))

(add-hook 'emacs-startup-hook #'greet-post-startup-complete)

#+end_src

* Local Variables :noexport:

Tangle on each file save.

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)
# End:

# emacs-init.org ends here.
# ------------------------------------------------------------------------------
