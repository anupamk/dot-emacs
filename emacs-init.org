#+TITLE: GNU Emacs Configuration
#+AUTHOR: Anupam Kapoor
#+EMAIL: anupam.kapoor@gmail.com
#+PROPERTY: header-args :tangle yes
# ----------------------------  ^^^ tangle all code blocks.

* Base Settings
** Disable gooey

+ I just want bare-bones windows with the modeline. GUI toolkit (gtk3
  these days) components f.e buttons, scroll-bars etc. don't really
  have any utility for me.

#+begin_src emacs-lisp

  (use-package emacs
    :config

    (blink-cursor-mode -1)
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (horizontal-scroll-bar-mode -1)

    ;; ---------------------------------------------------------------------------
    ;; i need some space man
    (setq-default line-spacing 0.15)

    (setq use-file-dialog nil)
    (setq use-dialog-box t)
    (setq inhibit-splash-screen t)
    (setq x-alt-keysym 'meta)

    ;; ---------------------------------------------------------------------------
    ;; remove whitespace before saving
    :hook (before-save-hook . whitespace-cleanup)

    :bind (("C-z"     . nil)
           ("C-x C-z" . nil)
           ("C-h h"   . nil)))

#+end_src

** Start Server

   + Start the emacs-server if not already running. New frames can
     connect to a running instance with appropriate =emacsclient -c=
     invokation.

#+begin_src emacs-lisp

  (use-package emacs
    :init
    (unless (and (fboundp 'server-running-p)
                 (server-running-p))
      (server-start)))

#+end_src

** User customizations in a separate location

+ Store all user customizations in a separate disposable location for
  saner behavior.

#+begin_src emacs-lisp

  (use-package emacs
    :config
    ;; -------------------------------------------------------------------------
    ;; customizations in a separate place all together
    (defvar anupamk:var/custom-file-name "~/.emacs.d/custom.el")
    (setq custom-file anupamk:var/custom-file-name)

    ;; -------------------------------------------------------------------------
    ;; load customizations once initialization is complete
    (defun anupamk/load-customizations ()
      (let ((customization-file anupamk:var/custom-file-name))
        (unless (file-exists-p customization-file)
          (make-empty-file customization-file))
        (load-file customization-file)))

    :hook (after-init-hook . anupamk/load-customizations))

#+end_src

** Unannoy

+ Saner defaults make the whole thing so much better

#+begin_src emacs-lisp

  (use-package emacs
    :config

    ;; -------------------------------------------------------------------------
    ;; dont show the startup screen
    (setf inhibit-startup-message t)

    ;; -------------------------------------------------------------------------
    ;; no scratchpad by default, we can always create one ourselves.
    ;; see `anupamk:utils/create-new-scratch-buffer' for more details
    (setf initial-scratch-message nil)

    ;; -------------------------------------------------------------------------
    ;; look ma, nobell
    (setf ring-bell-function (lambda()))

    ;; -------------------------------------------------------------------------
    ;; littering is a punishable offence in this and other states.
    (setf backup-inhibited t
          auto-save-default nil
          make-backup-files nil
          create-lockfiles nil)

    ;; -------------------------------------------------------------------------
    ;; prefix for generating auto-save-list-file-name
    (setf auto-save-list-file-prefix (locate-user-emacs-file "local/saves"))

    ;; -------------------------------------------------------------------------
    ;; echo unfinished commands after 0.1 seconds of pause
    (setf echo-keystrokes 0.1)

    ;; -------------------------------------------------------------------------
    ;; allow single character to delete a region
    (setf delete-active-region nil)

    ;; -------------------------------------------------------------------------
    ;; nullify function that is invoked to handle disabled commands i.e. all
    ;; commands work normally
    (setf disabled-command-function nil)

    ;; -------------------------------------------------------------------------
    ;; prefer loading newer `.el' files over older `.elc'
    (setf load-prefer-newer t)

    ;; -------------------------------------------------------------------------
    ;; enable column numbers
    (setq column-number-mode t)

    ;; -------------------------------------------------------------------------
    ;; merge system and emacs clipboard
    (setq select-enable-clipboard t)
    (setq select-enable-primary t)

    ;; -------------------------------------------------------------------------
    ;; get rid of the insert key
    (define-key global-map [(insert)] nil)

    ;; -------------------------------------------------------------------------
    ;; prevent accidental emacs-kill
    (global-set-key (kbd "C-x C-c") (lambda()
                                      (interactive)
                                      (message "terminate this emacs session with \'M-x kill-emacs\'")))

    ;; -------------------------------------------------------------------------
    ;; disable full 'yes' or 'no' (from emacs-28 onwards)
    (setq use-short-answers t)

    ;; -------------------------------------------------------------------------
    ;; prefer utf-8 encoding
    (prefer-coding-system         'utf-8)
    (set-terminal-coding-system   'utf-8)
    (set-keyboard-coding-system   'utf-8)
    (set-language-environment     'utf-8)
    (set-selection-coding-system  'utf-8)
    (setq locale-coding-system    'utf-8)
    (setq coding-system-for-read  'utf-8)
    (setq coding-system-for-write 'utf-8)
    (setq default-process-coding-system '(utf-8-unix . utf-8-unix))

    ;; -------------------------------------------------------------------------
    ;; additional space to put between lines when displaying a buffer
    (setq-default line-spacing -1)

    ;; -------------------------------------------------------------------------
    ;; no tabs in sources
    (setq-default indent-tabs-mode nil)

    ;; -------------------------------------------------------------------------
    ;; display buffer at its previous position
    (setq switch-to-buffer-preserve-window-point t)

    ;; -------------------------------------------------------------------------
    ;; completion before indent
    (setq tab-always-indent 'complete)

    ;; -------------------------------------------------------------------------
    ;; all themes are safe
    (setq custom-safe-themes t)

    ;; ---------------------------------------------------------------------------
    ;; write over selected text on input. just like other editors.
    (delete-selection-mode t)

    ;; ---------------------------------------------------------------------------
    ;; less noisy emacs-lisp compilation
    (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
    (setq native-comp-async-report-warnings-errors nil)

    ;; ---------------------------------------------------------------------------
    ;; max number of bytes to read from a process in a single chunk. 4m
    ;; is reasonable for lsp based c/c++ programming...
    (setq read-process-output-max (* 4 1024 1024))

    )

#+end_src

** Delight

   Edit / rename / remove modeline lighters for different packages.

   #+begin_src emacs-lisp

     (use-package delight
       :ensure
       :after use-package)

   #+end_src

** Package lists

   #+begin_src emacs-lisp

     (use-package package
       :commands (list-packages
                  package-refresh-contents
                  package-list-packages)
       :hook (package-menu-mode . hl-line-mode))

   #+end_src

* Utility functions

+ =use-package= allows declaring functions with the =:functions=
  stanza in a package definition. Such functions are then made
  available to the byte compiler

+ define a bunch of commonly used utility functions

#+begin_src emacs-lisp

  (use-package emacs

    :functions (anupamk:utils/change-cursor-style
                anupamk:utils/insert-current-date
                anupamk:utils/rename-current-buffer-file
                anupamk:utils/create-new-scratch-buffer
                anupamk:utils/host-name-is
                anupamk:utils/vi-match-paren
                anupamk:utils/fill-to-end
                anupamk:utils/copy-file-name-to-clipboard
                anupamk:utils/toggle-invisibles
                anupamk:utils/toggle-line-numbers
                anupamk:utils/auto-fill-comments
                anupamk:utils/dired-open-all-marked-files
                anupamk:utils/revert-all-buffers
                anupamk:utils/unbold-all-faces
                anupamk:utils/create-numbered-vterm-instance)

    :config

    ;; ---------------------------------------------------------------------------
    ;; change the cursor style
    (defun anupamk:utils/change-cursor-style (cursor-type)
      "Set the cursor type of the selected frame to CURSOR-TYPE.
       When called interactively, prompt for the type to use.
       To get the frame's current cursor type, use `frame-parameters'."
      (interactive)
      (list (intern (completing-read "Cursor type: "
                                     (mapcar 'list '("box" "hollow" "bar" "hbar" nil)))))
      (modify-frame-parameters (selected-frame) (list (cons 'cursor-type cursor-type))))

    ;; ---------------------------------------------------------------------------
    ;; insert current date
    (defun anupamk:utils/insert-current-date (iso)
      " Insert the current date at point.
        When ISO is non-nil, insert the date in ISO 8601 format.
        Otherwise insert the date as Mar 04, 2014.
      "
      (interactive "P")
      (insert (format-time-string (if iso "%F" "%b %d, %Y"))))

    ;; ---------------------------------------------------------------------------
    ;; rename current buffer to the desired name. the current name is copied
    ;; so you can just modify it, rather than typing it from scratch
    (defun anupamk:utils/rename-current-buffer-file ()
      "Renames current buffer and file it is visiting."
      (interactive)
      (let ((name (buffer-name))
            (filename (buffer-file-name)))
        (if (not (and filename (file-exists-p filename)))
            (error "Buffer '%s' is not visiting a file!" name)
          (let ((new-name (read-file-name "New name: " filename)))
            (if (get-buffer new-name)
                (error "A buffer named '%s' already exists!" new-name)
              (rename-file filename new-name 1)
              (rename-buffer new-name)
              (set-visited-file-name new-name)
              (set-buffer-modified-p nil)
              (message "File '%s' successfully renamed to '%s'"
                       name (file-name-nondirectory new-name)))))))


    ;; ---------------------------------------------------------------------------
    ;; shortcut to create scratch buffers.
    (defun anupamk:utils/create-new-scratch-buffer ()
      "create a new scratch buffer to work in. (could be *scratch* - *scratch-X*)"
      (interactive)
      (let ((n 0)
            bufname)
        (while (progn
                 (setq bufname (concat
                                "*scratch-"
                                (int-to-string n)
                                "*"))
                 (setq n (1+ n))
                 (get-buffer bufname)))
        (switch-to-buffer (get-buffer-create bufname))
        (if (= n 1) initial-major-mode))) ; 1, because n was incremented

    ;; ---------------------------------------------------------------------------
    ;; hostname predicate
    (defun anupamk:utils/host-name-is (host_name)
      "return true if host-name is `host_name'"
      (string-equal (system-name) host_name))

    ;; ---------------------------------------------------------------------------
    ;; did vi(m) get anything right ? paren matching probably...
    (defun anupamk:utils/vi-match-paren (arg)
      "Go to the matching paren if on a paren; otherwise insert %."
      (interactive "p")
      (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
            ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
            (t (self-insert-command (or arg 1)))))


    ;; ---------------------------------------------------------------------------
    ;; fill current line with '-' upto '80' columns, let the user have
    ;; the satisfaction of inserting a newline
    (defun anupamk:utils/fill-to-end ()
      (interactive)
      (progn
        (insert-char ?- (- 80 (current-column)))))

    ;; ---------------------------------------------------------------------------
    ;; copy file name to clipboard
    (defun anupamk:utils/copy-file-name-to-clipboard ()
      "Copy the current buffer file name to the clipboard."
      (interactive)
      (let ((filename (if (equal major-mode 'dired-mode)
                          default-directory
                        (buffer-file-name))))
        (when filename
          (kill-new filename)
          (message "Copied buffer file name '%s' to the clipboard." filename))))

    ;; ---------------------------------------------------------------------------
    ;; toggle display of invisible characters
    (defun anupamk:utils/toggle-invisibles ()
      "toggle display of invisible characters"
      (interactive)
      (if (bound-and-true-p whitespace-mode)
          (whitespace-mode -1)
        (whitespace-mode)))

    ;; ---------------------------------------------------------------------------
    ;; toggle display of line-numbers
    (defun anupamk:utils/toggle-line-numbers ()
      "toggle display of line-numbers in all buffers"
      (interactive)
      (if (bound-and-true-p display-line-numbers-mode)
          (display-line-numbers-mode -1)
        (display-line-numbers-mode)))

    ;; ---------------------------------------------------------------------------
    ;; auto fill comments in programming modes only
    (defun anupamk:utils/auto-fill-comments ()
      "comments in programming mode are automatically filled"
      (setq-local comment-auto-fill-only-comments t)
      (auto-fill-mode 1))

    ;; ---------------------------------------------------------------------------
    ;; open all marked files in a dired buffer f.e. via M-x find-dired
    (defun anupamk:utils/dired-open-all-marked-files ()
      "open all marked files in a dired buffer"
      (interactive)
      (mapc 'find-file (dired-get-marked-files)))

    ;; ---------------------------------------------------------------------------
    ;; revert all buffers that are open without any confirmation, and
    ;; ignoring all errors. useful for those cases when you change git
    ;; branches and want to have the same set of buffers to be around in
    ;; the new branch as well.
    (defun anupamk:utils/revert-all-buffers ()
      "revert all file buffers without any confirmation. buffers visiting files
  that are not readable (including those that do no longer exist) are ignored.
  other errors while reverting a buffer are reported only as messages."
      (interactive)
      (let (file)
        (dolist (buf  (buffer-list))
          (setq file  (buffer-file-name buf))
          (when (and file  (file-readable-p file))
            (with-current-buffer buf
              (with-demoted-errors "Error: %S" (revert-buffer t t)))))))


    ;; ---------------------------------------------------------------------------
    ;; bold faces are quite annoying. remove them all...
    (defun anupamk:utils/unbold-all-faces ()
      "unbold all faces in emacs"
      (interactive)
      (mapc (lambda (face)
              (when (eq (face-attribute face :weight) 'bold)
                (set-face-attribute face nil :weight 'normal)))
            (face-list)))

    ;; ---------------------------------------------------------------------------
    ;; create sequentially numbered vterm instances.
    (defun anupamk:utils/create-numbered-vterm-instance ()
      "create sequentially numbered vterm instances"
      (interactive)
      (if (not (boundp 'term-instance))
          (defvar term-instance 0 "terminal instance"))
      (setq term-instance (+ 1 term-instance))
      (command-execute 'vterm)
      (rename-buffer (format "*term-%03d*" term-instance)))

    ;; ---------------------------------------------------------------------------
    ;; saved kbd-macro to lineup next comment seperator in a c++
    ;; source. this will ensure that the line
    ;;     '/// ----'
    ;; extends to the last terminating column in the source
    ;; file. normally, as new blocks are introduced || removed
    ;; etc. comment seperators don't terminate at the right column.
    ;;
    ;; for running this on the whole file, do this:
    ;;    C-u <some-large-number> anupamk:utils/lineup-c++-comment-seperator
    (fset 'anupamk:utils/lineup-c++-comment-seperator
      (kmacro-lambda-form [?\C-s ?/ ?/ ?/ ?\C-a ?\C-s ?/ ?/ ?/ ?  ?- ?- ?- ?\C-a ?\C-k ?\M-\; ?\C-c ?e down ?\C-a ?\C-a] 0 "%d"))

    )

#+end_src

* Interface and interactions
** Appearance
*** Font Configuration

    + On high dpi displays, I have found =Pragmata= to be excellent
      typeface for text based interactions. Use that.

    + Moreover we want host specific settings for this.

    #+begin_src emacs-lisp

      (use-package emacs
        :config

        (defconst anupamk:font/default-font-name "Pragmata Pro Mono"
          "the default font that we use everywhere")

        ;; ---------------------------------------------------------------------------
        ;; host specific absolute font-heights
        (let ((anupamk/buffer-font-height (cond ((anupamk:utils/host-name-is "pnq-dev-01.pnq.taranawireless.com") 120)
                                                ((anupamk:utils/host-name-is "aws-devel-01") 120)
                                                (t 95))))

          ;; -------------------------------------------------------------------------
          ;; notice that we have absolute point size only for the default
          ;; face. heights of fixed-pitch and variable-pitch are _relative_
          ;; to that (see, set-face-attribute documentation for more info)
          (set-face-attribute 'default nil        :family anupamk:font/default-font-name :height anupamk/buffer-font-height)
          (set-face-attribute 'fixed-pitch nil    :family anupamk:font/default-font-name :height 1.0)
          (set-face-attribute 'variable-pitch nil :family anupamk:font/default-font-name :height 1.0))

        ;; ---------------------------------------------------------------------------
        ;; bold faces are quite annoying. remove them all
        (defun anupamk:utils/unbold-all-faces ()
          "unbold all faces in emacs"
          (interactive)
          (mapc (lambda (face)
                  (when (eq (face-attribute face :weight) 'bold)
                    (set-face-attribute face nil :weight 'normal)))
                (face-list)))

        ;; for the compilation buffer, reduce the font size, we can always
        ;; increase it if required.
        (defun setup-compilation-buffer-font()
          (interactive)
          (setq buffer-face-mode-face '(:family "Go Mono" :height 80))
          (buffer-face-mode))

        :hook
        (emacs-startup-hook . anupamk:utils/unbold-all-faces)
        (compilation-mode-hook . setup-compilation-buffer-font))

    #+end_src

*** Color theme

    + I /really/ love the low-contrast =zenburn= theme for long term
      interactions with Emacs.

 #+begin_src emacs-lisp

   (use-package zenburn-theme
     :ensure
     :config
     :custom-face
     (diff-added    ((t :foreground "green"   :underline nil)))
     (diff-removed  ((t :foreground "red"     :underline nil)))
     (highlight     ((t :background "#989890" :underline nil))))

 #+end_src

*** Frame Configuration

    + All frames have a golden cursor sans vertical or horizontal
      scroll bars.

 #+begin_src emacs-lisp

   (use-package emacs
     :init
     (load-theme 'zenburn :no-confirm)

     :config
     (setq default-frame-alist '((cursor-color               . "gold")
                                 (mouse-color                . "gold")
                                 (vertical-scroll-bars       . nil)
                                 (horizontal-scroll-bar-mode . nil)
                                 ))

     ;; ---------------------------------------------------------------------------
     ;; remove bold fonts from all frames...
     (add-hook 'after-make-frame-functions
               (lambda(current-frame)
                 (with-selected-frame current-frame
                   (anupamk:utils/unbold-all-faces)))))

 #+end_src

*** Fringe Configuration

    + Fringes are areas on left and right side of an Emacs frame which
      are typically used to show status related feedback.

    + Default =8= pixel wide fringe on both sides of an Emacs frame is
      just too much for my taste. I just configure it to be =6= pixels
      wide on the left side of the frame, and =0= pixels wide on the
      right side.

 #+begin_src emacs-lisp

   (use-package fringe
     :config
     (fringe-mode '(6 . 0))
     (setq-default fringes-outside-margins nil)
     (setq-default indicate-buffer-boundaries nil)
     (setq-default indicate-empty-lines nil)
     (setq-default overflow-newline-into-fringe t))

 #+end_src

** Some semblance of mouse sanity in emacs

+ Default mouse behavior in Emacs can be agumented with some saner
  defaults.

#+begin_src emacs-lisp

  (use-package emacs
    :config
    ;; -------------------------------------------------------------------------
    ;; some semblance of mouse sanity in emacs

    ;; enable `sloppy' focus on emacs-frames aka what is good in fvwm2 is also
    ;; good in emacs
    (setq mouse-autoselect-window t)

    ;; copy to kill-ring upon mouse adjustments of the region.
    (setq mouse-drag-copy-region t)

    ;; resize frames independent of `frame-char-{height,width}'
    (setq frame-resize-pixelwise t)

    ;; -------------------------------------------------------------------------
    ;; how much should we scroll when the mouse-wheel is spun around ? when the
    ;; <CTRL> key is held, change the size of text in the buffer
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)
                                        ((control) . text-scale)))

    )


#+end_src

** Visual feedback for common activities

+ Incremental search and query replace highlight is quite useful.
+ Highlight regions when the mark is active.
+ Highlight current line in all windows in all modes.
+ Show matching parenthesis.

#+begin_src emacs-lisp

  (use-package emacs
    :config

    ;; -------------------------------------------------------------------------
    (setq search-highlight t)
    (setq query-replace-highlight t)
    (setq transient-mark-mode t)

    ;; -------------------------------------------------------------------------
    ;; enable highlighting on current line as well as current line on all
    ;; windows.
    (require 'hl-line)
    (custom-set-variables '(global-hl-line-sticky-flag t))
    (global-hl-line-mode 1)

    ;; ---------------------------------------------------------------------------
    ;; highlight matching parenthesis quickly in the most unobtrusive way
    ;; possible
    (require 'paren)
    (setq show-paren-style 'parenthesis)
    (setq show-paren-delay 0)

    ;; ---------------------------------------------------------------------------
    ;; who sez color is bad ? a.n.g.r.y fruit bowl
    (set-face-foreground 'show-paren-mismatch "orange red")
    (set-face-background 'show-paren-match "black")
    (set-face-foreground 'show-paren-match "gold")
    (show-paren-mode t))

#+end_src

** Modeline customizations

   #+begin_src emacs-lisp

     (use-package telephone-line
       :ensure
       :config

       (telephone-line-defsegment anupamk/telephone-line-segment-clock ()
         "display current time"
         (format-time-string "[%H:%M %m/%d]"))

       ;; ---------------------------------------------------------------------------
       ;; lhs of modeline
       (setq telephone-line-lhs '((nil . (telephone-line-buffer-segment
                                          telephone-line-position-segment
                                          anupamk/telephone-line-segment-clock))))

       ;; ---------------------------------------------------------------------------
       ;; rhs of modeline
       (setq telephone-line-rhs '((accent . (telephone-line-vc-segment))))

       :hook (after-init-hook . (lambda() (telephone-line-mode 1))))

   #+end_src

* Keyboard configuration
** Global keys
 + Years of Emacs use has resulted in some good, and some not so good
   keybindings. These are all defined here.

 + In Emacs Lisp, if =foo= is a symbol, then ='foo= and =#'foo= are
   completely equivalent. The latter form (with =#'=) is preferred when
   =foo= is a function, as it documents the fact that it is intended to
   be funcalled.

 #+begin_src emacs-lisp

   (use-package emacs
     :config

     ;; -------------------------------------------------------------------------
     ;; <meta-g> : goes to a specific line
     (global-set-key (kbd "C-c g") #'goto-line)

     ;; -------------------------------------------------------------------------
     ;; recenter current line
     (global-set-key (kbd "C-c r") #'recenter)

     ;; -------------------------------------------------------------------------
     ;; jump to begining / end of buffer
     (global-set-key (kbd "C-c <end>")  #'end-of-buffer)
     (global-set-key (kbd "C-c <home>") #'beginning-of-buffer)

     ;; -------------------------------------------------------------------------
     ;; create a new scratch buffer
     (global-set-key (kbd "C-c s") #'anupamk:utils/create-new-scratch-buffer)

     ;; -------------------------------------------------------------------------
     ;; rename current buffer
     (global-set-key (kbd "C-c C-x C-r") #'anupamk:utils/rename-current-buffer-file)

     ;; -------------------------------------------------------------------------
     ;; vi style parenthesis matching
     (global-set-key (kbd "%") #'anupamk:utils/vi-match-paren)

     ;; -------------------------------------------------------------------------
     ;; regex search always
     (global-set-key [remap isearch-forward]  #'isearch-forward-regexp)
     (global-set-key [remap isearch-backward] #'isearch-backward-regexp)

     ;; -------------------------------------------------------------------------
     ;; visual demarcation in code
     (global-set-key (kbd "C-c e") #'anupamk:utils/fill-to-end)

     ;; ------------------------------------------------------------------------
     ;; <esc> to quit from a command
     (global-set-key (kbd "<escape>") #'keyboard-escape-quit)

     ;; ---------------------------------------------------------------------------
     ;; create a new-frame
     (global-set-key (kbd "C-c C-n") #'make-frame)

     ;; ---------------------------------------------------------------------------
     ;; define some keybindings via the `C-x t` prefix, for toggling
     ;; different behaviors.
     ;;
     ;; just rollls off the tongue doesn't it ?
     (bind-keys :prefix-map toggle-map
                :prefix "C-c t"
                ("i" . anupamk:utils/toggle-invisibles)
                ("l" . anupamk:utils/toggle-line-numbers)
                ("f" . hs-toggle-hiding)
                ("t" . text-mode)
                ("R" . anupamk:tramp/edit-file-with-sudo))
     )

 #+end_src

** Window movement

   + Emacs already has =windmove= package which provides a set of
     routines to for selection of windows in a frame
     geometrically. Thus, =windmove-left= will select a window
     immediately to the left of the current selected window etc.

   + FWIW, =julia-assange= (yes, /that/ one) had
     =change-windows-intuitively.el= which predated this !


     #+begin_src emacs-lisp

       (use-package windmove
         :ensure
         :delight
         :commands windmove
         :config

         ;; --------------------------------------------------------------------
         ;; movement that falls-of-the-edge of the frame will wrap around to
         ;; find the window on the opposite side of the frame.
         (setq windmove-wrap-around t)

         :bind (("C-<M-up>"    . windmove-up)
                ("C-<M-down>"  . windmove-down)
                ("C-<M-left>"  . windmove-left)
                ("C-<M-right>" . windmove-right)))

     #+end_src

** Buffer movement

   + With =buffer-move=, Emacs provides builtin functionality for
     moving buffers in various windows much more easily than =C-x b=
     everywhere.


   #+begin_src emacs-lisp

     (use-package buffer-move
       :ensure
       :delight
       :commands buffer-move

       :bind (("C-S-<up>"     . buf-move-up)
              ("C-S-<down>"   . buf-move-down)
              ("C-S-<left>"   . buf-move-left)
              ("C-S-<right>"  . buf-move-right)))

   #+end_src

* Selection candidates and search methods
** Completion framework

*** Consult+Orderless+Vertico+Marginalia

    + IMHO, optimal way of using Emacs is via searching and narrowing
      selection candidates.

      #+begin_src emacs-lisp

        ;; -----------------------------------------------------------------------------
        ;; consult provides various practical commands based on the Emacs
        ;; completion function completing-read, which allows to quickly select
        ;; an item from a list of candidates with completion.
        (use-package consult
          :ensure t

          ;; ---------------------------------------------------------------------------
          ;; init configuration is always executed
          :init

          ;; ---------------------------------------------------------------------------
          ;; configure other variables and modes here, after lazily loading
          ;; the package
          :config

          ;; ---------------------------------------------------------------------------
          ;; show absolute line-numbers when narrowing is active
          (setq consult-line-numbers-widen t)

          ;; ---------------------------------------------------------------------------
          ;; setup the project root for `project.el'
          (setq consult-project-root-function
                (lambda ()
                  (when-let (project (project-current))
                    (car (project-roots project)))))

          ;; ---------------------------------------------------------------------------
          ;; replace bindings
          :bind (("C-x M-:"    . consult-complex-command)
                 ("C-x b"    . consult-buffer)
                 ("C-x C-b"  . consult-buffer)
                 ("C-c b"    . project-find-file)
                 ("C-c B"    . bookmark-set)
                 ("C-c h"    . consult-history)
                 ("C-c i"    . consult-imenu)
                 ("C-c I"    . consult-project-imenu)
                 ("C-c k"    . consult-ripgrep)
                 ("C-c K"    . consult-git-grep)
                 ("C-c l"    . consult-locate)
                 ("C-c m"    . consult-mode-command)
                 ("C-c s"    . consult-line)
                 ("C-x r x"  . consult-register)
                 ("C-x r b"  . consult-bookmark)
                 ("M-g b"    . consult-bookmark)
                 ("M-g m"    . consult-mark)
                 ("M-g e"    . consult-error)
                 ("M-s m"    . consult-multi-occur)
                 ("M-s o"    . consult-outline)
                 ("M-y"      . consult-yank-pop)
                 ("C-s"      . isearch-forward)
                 ("C-S-s"    . consult-line)
                 ("<help> a" . consult-apropos))
          )

        ;; -----------------------------------------------------------------------------
        ;; orderless provides an orderless completion style that divides the
        ;; pattern into space-separated components, and matches candidates
        ;; that match all of the components in any order. Each component can
        ;; match in any one of several ways: literally, as a regexp, as an
        ;; initialism, in the flex style, or as multiple word prefixes. By
        ;; default, regexp and literal matches are enabled.
        (use-package orderless
          :ensure t
          :init
          (setq completion-styles '(orderless)
                completion-category-defaults nil
                completion-category-overrides '((file (styles . (partial-completion))))))


        ;; -----------------------------------------------------------------------------
        ;; vertico provides a performant and minimalistic vertical completion
        ;; UI, which is based on the default completion system. By reusing the
        ;; built-in facilities system, Vertico achieves full compatibility
        ;; with built-in Emacs completion commands and completion
        ;; tables. Vertico only provides the completion UI but aims to be
        ;; flexible and extensible.
        (use-package vertico
          :ensure t

          :config
          ;; ---------------------------------------------------------------------------
          ;;  borrowed from:
          ;;  https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608
          (defun anupamk:utils/minibuffer-kill-backwards (arg)
            "when minibuffer is completing a file-name, delete upto
        parent directory, otherwise delete a word"
            (interactive "p")
            (if minibuffer-completing-file-name
                (if (string-match-p "/." (minibuffer-contents))
                    (zap-up-to-char (- arg) ?/)
                  (delete-minibuffer-contents))
              (backward-kill-word arg)))

          :custom
          (vertico-cycle t)

          :custom-face
          (vertico-current ((t (:background "#383838"))))

          :bind (:map vertico-map
                      ("C-n" . vertico-next)
                      ("C-p" . vertico-previous)
                      ("C-q" . vertico-exit)
                      :map minibuffer-local-map
                      ("M-h" . anupamk:utils/minibuffer-kill-backwards))

          :init
          (vertico-mode)

          )

        ;; -----------------------------------------------------------------------------
        ;; marginalia provides marks or annotations placed at the margin of
        ;; the minibuffer for completion candidates.
        (use-package marginalia
          :ensure t
          :after vertico

          :custom
          ((marginalia-align-offset 1)
           (marginalia-margin-threshold 200)
           (marginalia-separator-threshold 120)
           (marginalia-truncate-width 100)
           (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))

          :init
          (marginalia-mode))


        ;; -----------------------------------------------------------------------------
        ;; this package provides a "contextual" menu proividing actions for
        ;; various objects (files, buffers, etc. etc.).
        (use-package embark
          :bind (("C-S-a" . embark-act)
                 :map minibuffer-local-map
                 ("C-d" . embark-act))
          :config

          ;; Show Embark actions via which-key
          (setq embark-action-indicator
                (lambda (map)
                  (which-key--show-keymap "Embark" map nil nil 'no-paging)
                  #'which-key--hide-popup-ignore-command)
                embark-become-indicator embark-action-indicator))

        (use-package embark-consult
          :ensure t
          :after (embark consult)
          :hook (embark-collect-mode . embark-consult-preview-minor-mode))

      #+end_src

** Enable wgrep

   With =wgrep= we can edit the results of grep invokation and save
   changes to affected buffers. Quite useful !

   #+begin_src emacs-lisp

     (use-package wgrep
       :ensure
       :config
       (setq wgrep-auto-save-buffer t)
       (setq wgrep-change-readonly-file t))

   #+end_src


** Isearch configuration

   #+begin_src emacs-lisp

     (use-package isearch
       :config
       (setq search-whitespace-regexp ".*?")
       (setq search-highlight t)
       (setq isearch-lax-whitespace t)
       (setq isearch-regexp-lax-whitespace nil)
       (setq isearch-lazy-highlight t)

       ;; ----------------------------------------------------------------------
       ;; these are newer...
       (setq isearch-lazy-count t)
       (setq lazy-count-prefix-format "(%s/%s) ")
       (setq lazy-count-suffix-format "[%s of %s]")
       (setq isearch-yank-on-move 'shift)
       (setq isearch-allow-scroll 'unlimited))

   #+end_src

* Directory management
** Perliminary dired configuration

   #+begin_src emacs-lisp

     (use-package dired
       :config
       (setq dired-recursive-copies 'always)

       ;; ----------------------------------------------------------------------
       ;; ask for confirmation on deletes only at the top-level, not for
       ;; subsequent ones
       (setq dired-recursive-deletes 'top)

       ;; ----------------------------------------------------------------------
       ;; show hidden directories and files before others
       (setq dired-listing-switches "-AFhlvt --group-directories-first")

       ;; ----------------------------------------------------------------------
       ;; do-what-i-mean target for quick dired operations
       (setq dired-dwim-target t)

       :hook ((dired-mode . dired-hide-details-mode)
              (dired-mode . hl-line-mode)))

   #+end_src

** Dired =aux= configuration

   #+begin_src emacs-lisp

     (use-package dired-aux
       :config
       (setq dired-isearch-filenames 'dwim)

       ;; ---------------------------------------------------------------------------
       ;; introduced in later Emacs versions
       (setq dired-create-destination-dirs 'always)
       (setq dired-vc-rename-file t))

   #+end_src

** Finding in dired buffers

   #+begin_src emacs-lisp

     (use-package find-dired
       :after dired
       :config
       (setq find-ls-option ;; applies to `find-name-dired'
             '("-ls" . "-AFhlv --group-directories-first"))
       (setq find-name-arg "-iname"))

   #+end_src

** Async dired

   #+begin_src emacs-lisp

     (use-package async
       :ensure
       :delight)

     (use-package dired-async
       :after (dired async)
       :hook (dired-mode . dired-async-mode))
   #+end_src

** Dynamically filter directory listing

   #+begin_src emacs-lisp

     (use-package dired-narrow
       :ensure
       :after dired
       :config
       (setq dired-narrow-exit-when-one-left t)
       (setq dired-narrow-enable-blinking t)
       (setq dired-narrow-blink-time 0.3)
       :bind (:map dired-mode-map
                   ("M-s n" . dired-narrow)))

   #+end_src

** Editable dired buffers

   #+begin_src emacs-lisp

     (use-package wdired
       :after dired
       :commands (wdired-mode
                  wdired-change-to-wdired-mode)
       :config
       (setq wdired-allow-to-change-permissions t)
       (setq wdired-create-parent-directories t))

   #+end_src

** Dired subtree

   #+begin_src emacs-lisp

     (use-package dired-subtree
       :ensure
       :after dired
       :bind (:map dired-mode-map
                   ("<tab>"           . dired-subtree-toggle)
                   ("<C-tab>"         . dired-subtree-cycle)
                   ("<S-iso-lefttab>" . dired-subtree-remove)))

   #+end_src

** Dired-X

   Enable additional features shipped with Emacs.

   #+begin_src emacs-lisp

     (use-package dired-x
       :after dired
       :bind (("C-c j"     . dired-jump)
              ("C-c C-j j" . dired-jump-other-window))

       :hook
       (dired-mode . (lambda ()
                       (setq dired-clean-confirm-killing-deleted-buffers t))))

   #+end_src

** Sorting dired buffers

   #+begin_src emacs-lisp

     (use-package dired-quick-sort
       ;; usage: hit 'S' in dired buffer, which brings up the sorting
       ;; menu. Sorting choice is remembered for new dired-buffers.
       :ensure
       :config
       (dired-quick-sort-setup))

   #+end_src

* Applications and utilties
** Which key

   =which-key= is a minor mode for Emacs that displays the key
   bindings following your currently entered incomplete command

   #+begin_src emacs-lisp

     (use-package which-key
       :ensure
       :commands which-key-C-h-dispatch
       :config

       (setq which-key-show-early-on-C-h t)
       (setq which-key-idle-delay 10000)
       (setq which-key-idle-secondary-delay 0.05)
       (setq which-key-popup-type 'side-window)
       (setq which-key-show-prefix 'echo)
       (setq which-key-max-display-columns 6)
       (setq which-key-separator " ")
       (setq which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL"))
       :hook (after-init . which-key-mode))

   #+end_src

** Uniquify file names in buffers

   #+begin_src emacs-lisp

     (use-package uniquify
       :config

       ;; forward                       bar/mumble/name    quux/mumble/name
       ;; reverse                       name\mumble\bar    name\mumble\quux
       ;; post-forward                  name|bar/mumble    name|quux/mumble
       ;; post-forward-angle-brackets   name<bar/mumble>   name<quux/mumble>
       ;; nil                           name               name<2>
       (setf uniquify-buffer-name-style 'post-forward-angle-brackets))

   #+end_src

** Record history
*** Recent files and directories

    #+begin_src emacs-lisp

      (use-package recentf
        :functions (rjs/recentf-rename-directory
                    rjs/recentf-rename-file
                    rjs/recentf-rename-notify
                    contrib/recentf-add-dired-directory)

        :config
        (setq recentf-save-file "~/.emacs.d/recentf")
        (setq recentf-max-menu-items 10)
        (setq recentf-max-saved-items 200)
        (setq recentf-show-file-shortcuts-flag nil)

        ;; rename entries in recentf when moving files in dired
        (defun rjs/recentf-rename-directory (oldname newname)
          ;; oldname, newname and all entries of recentf-list should already
          ;; be absolute and normalised so I think this can just test whether
          ;; oldname is a prefix of the element.
          (setq recentf-list
                (mapcar (lambda (name)
                          (if (string-prefix-p oldname name)
                              (concat newname (substring name (length oldname)))
                            name))
                        recentf-list))
          (recentf-cleanup))

        (defun rjs/recentf-rename-file (oldname newname)
          (setq recentf-list
                (mapcar (lambda (name)
                          (if (string-equal name oldname)
                              newname
                            oldname))
                        recentf-list))
          (recentf-cleanup))

        (defun rjs/recentf-rename-notify (oldname newname &rest args)
          (if (file-directory-p newname)
              (rjs/recentf-rename-directory oldname newname)
            (rjs/recentf-rename-file oldname newname)))

        (advice-add 'dired-rename-file :after #'rjs/recentf-rename-notify)

        (defun contrib/recentf-add-dired-directory ()
          "Include Dired buffers in the `recentf' list.  Particularly
      useful when combined with a completion framework's ability to
      display virtual buffers."
          (when (and (stringp dired-directory)
                     (equal "" (file-name-nondirectory dired-directory)))
            (recentf-add-file dired-directory)))

        :hook ((after-init . recentf-mode)
               (dired-mode . contrib/recentf-add-dired-directory)))

    #+end_src

*** Minibuffer

    + Not sure why saving history is not default. Let's enable that,
      and few more things that make sense f.e. search, kill, regexp-search etc.

    #+begin_src emacs-lisp

      (use-package savehist
        :config
        (setq savehist-file "~/.emacs.d/savehist")
        (setq history-length 10000)
        (setq history-delete-duplicates t)
        (setq savehist-save-minibuffer-history t)

        ;; ---------------------------------------------------------------------------
        ;; nice to have
        (setq savehist-additional-variables '(kill-ring
                                              search-ring
                                              regexp-search-ring))
        (savehist-mode 1))

    #+end_src

*** Point

    Where is the point at ?

    #+begin_src emacs-lisp

      (use-package saveplace
        :config
        (setq save-place-file "~/.emacs.d/saveplace")
        (save-place-mode 1))

    #+end_src
*** Desktop state
    Use =desktop+= for saving and restoring desktop state.

    #+begin_src emacs-lisp

      (use-package desktop+
        :ensure

        :config
        ;; ---------------------------------------------------------------------------
        ;; from : https://stackoverflow.com/questions/18612742/emacs-desktop-save-mode-error
        (setq desktop-restore-forces-onscreen nil)

        ;; not much to do except that we use desktop+-create-auto and
        ;; desktop+-load-auto for automatically generating desktop-names
        ;; while saving and restoring desktop sessions
        )

    #+end_src
** Dynamic word completion

   #+begin_src emacs-lisp

     (use-package dabbrev
       :commands dabbrev-expand
       :delight
       :config
       (setq dabbrev-abbrev-char-regexp nil)
       (setq dabbrev-backward-only nil)
       (setq dabbrev-case-distinction nil)
       (setq dabbrev-case-fold-search t)
       (setq dabbrev-case-replace nil)
       (setq dabbrev-eliminate-newlines nil)
       (setq dabbrev-upcase-means-case-search t))

     (use-package hippie-exp
       :delight
       :after dabbrev
       :commands hippie-expand
       :config
       (setq hippie-expand-try-functions-list
             '(try-expand-dabbrev
               try-expand-dabbrev-visible
               try-expand-dabbrev-from-kill
               try-expand-dabbrev-all-buffers
               try-expand-list
               try-expand-list-all-buffers
               try-expand-line
               try-expand-line-all-buffers
               try-complete-file-name-partially
               try-complete-file-name
               try-expand-all-abbrevs))
       (setq hippie-expand-verbose t))


   #+end_src
** Auto revert

   #+begin_src emacs-lisp

     (use-package autorevert
       :config
       (global-auto-revert-mode 1))

   #+end_src
** Version control
*** Magit

    #+begin_src emacs-lisp

      (use-package magit
        :ensure
        :diminish
        :config

        ;; ---------------------------------------------------------------------------
        ;; whether to show word-granularity differences within diff hunks
        (setq magit-diff-refine-hunk t)

        ;; ---------------------------------------------------------------------------
        ;; move untracked files section behind Unstaged changes section
        (magit-add-section-hook 'magit-status-sections-hook
                                'magit-insert-untracked-files
                                'magit-insert-unpushed-commits t)

        (remove-hook 'git-commit-finish-query-functions
                     'git-commit-check-style-conventions)

        :bind  (("C-c g" . magit-status)
                ("C-c l" . magit-log)
                ("C-h B" . magit-blame)))

    #+end_src
*** Magit filenotify and git-timemachine setup

    #+begin_src emacs-lisp

      (use-package magit-filenotify
        :requires filenotify
        :ensure
        :delight
        :config
        (define-key magit-status-mode-map (kbd "`") 'magit-filenotify-mode))

      (use-package git-timemachine :ensure t)

    #+end_src

*** Diff highlight

    #+begin_src emacs-lisp

      (use-package diff-hl
        :ensure
        :delight
        :init
        (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)

        :config

        ;; enable it in all buffers
        (global-diff-hl-mode))

    #+end_src

*** Git overview in dired

    #+begin_src emacs-lisp

      (use-package dired-git-info
        :ensure
        :after dired
        :config
        (setq dgi-commit-message-format "%h\t%s\t%cr")
        :bind (:map dired-mode-map
                    (")" . dired-git-info-mode)))

    #+end_src

** TRAMP configuration

   #+begin_src emacs-lisp

     (use-package tramp
       :ensure

       :functions (anupamk:tramp/edit-file-with-sudo
                   anupamk:tramp/find-file-root-header-warning)
       :config

       ;; ---------------------------------------------------------------------------
       ;; see relevant section of `~/settings/dot.zshrc' for more
       ;; information on how this customization works
       (setq tramp-terminal-type "tramp")

       ;; ---------------------------------------------------------------------------
       ;; setup a verbose tramp session
       (setq tramp-verbose 9)

       ;; ---------------------------------------------------------------------------
       ;; the default method for file transfer
       (setq tramp-default-method "ssh")

       ;; ---------------------------------------------------------------------------
       ;; display a red-banner across the file when it is being edited as root
       (defun anupamk:tramp/find-file-root-header-warning ()
         "*Display a warning in header line of the current buffer.
     This function is suitable to add to `find-file-hook'."

         ;; -------------------------------------------------------------------------
         ;; file opened as user == root ?
         (when (string-equal (file-remote-p (or buffer-file-name default-directory) 'user)
                             "root")

           ;; -----------------------------------------------------------------------
           ;; header warning face
           (make-face 'anupamk:tramp/find-file-root-header-face)
           (set-face-attribute 'anupamk:tramp/find-file-root-header-face nil
                               :height 1.2
                               :width 'normal
                               :foreground "white"
                               :background "dark red")

           (let* ((warning " WARNING: EDITING FILE AS ROOT! ")

                  ;; ----------------------------------------------------------------
                  ;; ok, so we want to account for the ':height' face-attribute as
                  ;; well, so that the warning text is not too badly skewed while
                  ;; getting displayed.
                  (space (- (truncate (/ (window-width)
                                         (face-attribute 'anupamk:tramp/find-file-root-header-face :height)))
                            (length warning)))

                  (bracket (make-string (+ 1 (/ space 2)) ?*))
                  (warning (concat bracket warning bracket)))

             (setq header-line-format (propertize
                                       warning 'face 'anupamk:tramp/find-file-root-header-face)))))

       (add-hook 'find-file-hook  #'anupamk:tramp/find-file-root-header-warning)
       (add-hook 'dired-mode-hook #'anupamk:tramp/find-file-root-header-warning)

       ;; ---------------------------------------------------------------------------
       ;; edit currently open file as root
       (defun anupamk:tramp/edit-file-with-sudo (&optional fname)
         "Take the file currently being edited, and open it as root with `sudo'."
         (interactive "P")
         (if (or fname (not buffer-file-name))
             (find-file (concat "/sudo::" (read-file-name "find file (as root): ")))
           (find-alternate-file (concat "/sudo::" buffer-file-name))))
       )

   #+end_src

** Bookmark places in buffer

   + Jump to a specific location with the =C-x r b= binding

   #+begin_src emacs-lisp

     (use-package bookmark
       :ensure
       :delight

       :functions (anupamk:bookmark/quick-save-bookmark)
       :config
       (defun anupamk:bookmark/quick-save-bookmark ()
         "Save bookmark with name as 'buffer:row:col'"
         (interactive)
         (bookmark-set (format "%s:%s:line %s:column %s"
                               (thing-at-point 'symbol)
                               (buffer-name)
                               (line-number-at-pos)
                               (current-column)))
         (message "Bookmarked saved at current position"))

       (setq bookmark-save-flag 1)

       :bind  (("C-c q s b" . anupamk:bookmark/quick-save-bookmark)))

   #+end_src

** Bindings for C.R.U.X

   Some bindings for `Collection of Ridiculously Useful eXtensions'

   #+begin_src emacs-lisp

     (use-package crux
       :ensure
       :bind (("C-a" . crux-move-beginning-of-line)))

   #+end_src

** Momentarily flashing text regions on prominent actions

   + The included =pulse= library provides functions to flash a region
     of text. The most useful general application is to flash the line
     the cursor is on as a navigational aid or accessibility feature.

   #+begin_src emacs-lisp

     (use-package emacs
       :init
       (require 'pulse)

       :functions (anupamk:pulse/pulse-line)

       :config
       (defun anupamk:pulse/pulse-line (&rest _)
         "Pulse the current line."
         (pulse-momentary-highlight-one-line (point)))

       ;; ----------------------------------------------------------------------
       ;; when do we want to flash ?
       (dolist (pulse-command '(scroll-up-command
                                scroll-down-command
                                recenter-top-bottom
                                windmove-up
                                windmove-down
                                windmove-right
                                windmove-left
                                windmove-wrap-around))

         (advice-add pulse-command :after #'anupamk:pulse/pulse-line)))

   #+end_src

** VTerm t.h.e full-fledged terminal within

   =vterm= is /fast/ full fledged terminal emulator within
   Emacs. Built as a dynamic module on top of libvterm, it provides an
   overall better experience as compared to alternatives
   f.e. =ansi-term=.

   With some minor tweaks to zsh configuration, we get better overall
   /harmonized/ interaction between the two.


   #+begin_src emacs-lisp

     (use-package vterm
       :ensure t
       :custom
       ;; ---------------------------------------------------------------------------
       ;; ignore bold text properties
       (vterm-disable-bold t)

       ;; ---------------------------------------------------------------------------
       ;; ignore underline text properties
       (vterm-disable-underline t)

       ;; ---------------------------------------------------------------------------
       ;; ignore inverse-video text properties
       (vterm-disable-inverse-video t)

       ;; ---------------------------------------------------------------------------
       ;; how big should the scrollback buffer be ?
       (vterm-max-scrollback 10000)

       ;; ---------------------------------------------------------------------------
       ;; Controls whether or not to exclude the prompt when copying a line
       ;; in vterm-copy-mode
       (vterm-copy-exclude-prompt t)

       :config

       ;; ---------------------------------------------------------------------------
       ;; set vterm buffer non-default font
       (defun anupamk/set-vterm-font ()
         "custom font in the vterm buffer"
         (interactive)
         (set (make-local-variable 'buffer-face-mode-face) '(:family "Go Mono" :height 80))
         (buffer-face-mode t))

       ;; ---------------------------------------------------------------------------
       ;; ensure that <C-backspace> should kill the previous word
       (define-key vterm-mode-map (kbd "<C-backspace>")
         (lambda () (interactive) (vterm-send-key (kbd "C-w"))))

       ;; ---------------------------------------------------------------------------
       ;; make counsel use correction function to yank in vterm buffers
       (defun vterm-counsel-yank-pop-action (orig-fun &rest args)
         (if (equal major-mode 'vterm-mode)
             (let ((inhibit-read-only t)
                   (yank-undo-function (lambda (_start _end) (vterm-undo))))
               (cl-letf (((symbol-function 'insert-for-yank)
                          (lambda (str) (vterm-send-string str t))))
                 (apply orig-fun args)))
           (apply orig-fun args)))

       (advice-add 'counsel-yank-pop-action :around #'vterm-counsel-yank-pop-action)

       ;; ---------------------------------------------------------------------------
       ;; directory tracking
       (add-to-list 'vterm-eval-cmds '("update-pwd" (lambda (path) (setq default-directory path))))

       ;; ---------------------------------------------------------------------------
       ;; open files below the current window
       (push (list "find-file-below"
                   (lambda (path)
                     (if-let* ((buf (find-file-noselect path))
                               (window (display-buffer-below-selected buf nil)))
                         (select-window window)
                       (message "Failed to open file: %s" path))))
             vterm-eval-cmds)

       (global-set-key (kbd "C-c C-<return>") #'anupamk:utils/create-numbered-vterm-instance)

       :hook
       (vterm-mode-hook . anupamk/set-vterm-font)

       )

   #+end_src

** Hide-Show For Code Folding

   + Code folding enables hiding and showing blocks of text in
     different buffers. Built in =hideshow= mode, makes this quite
     seamless experience.

   + Add that by default to all programming modes. The `C-x t` prefix
     for toggle-map, then binds =C-x t f= for toggling this behavior.

   #+begin_src emacs-lisp


     (use-package hideshow
       :ensure t
       :config

       :hook
       ((prog-mode-hook . hs-minor-mode))

       )

   #+end_src

** Org Roam

   + Org-Roam is a system note-taking which can be linked together
     creating a =network knowledge base=

   + It is inspired by a program called =roam= and a note taking
     strategy called =Zettlekasten=, also called a =second brain=.

     #+begin_src emacs-lisp

       ;; -----------------------------------------------------------------------------
       (use-package org-roam
         :ensure t

         :init

         ;; ---------------------------------------------------------------------------
         ;; don't display the annoying warning message about upgrading
         ;; org-roam to v2. because it needs to be defined _before_ package
         ;; is loaded, we do this in the `init' section of the config.
         (setq org-roam-v2-ack t)

         :custom
         (org-roam-directory "~/source-code/roam-notes")
         (org-roam-completion-everywhere t)

         :bind (("C-c n l" . org-roam-buffer-toggle)
                ("C-c n f" . org-roam-node-find)
                ("C-c n i" . org-roam-node-insert)

                :map org-mode-map
                ("C-M-i" . completion-at-point))

         :config
         (org-roam-setup))

     #+end_src

** Dumb-Jump

   + Dumb Jump is an Emacs "jump to definition" package for large
     number of programming languages that favors "it just works ",
     with a minimal (or as close to zero as possible) configuration.

   + As opposed to other canonical packages, there are no stored
     indexes f.e. TAGS, cscope.db, .cache (clangd etc) etc, or
     persistent background processes.

   + In the current configuration, we resort to using =ripgrep= to
     find potential definitions of symbols.

   #+begin_src emacs-lisp

     (use-package dumb-jump
       :ensure

       :config
       (setq dumb-jump-force-searcher 'rg)

       ;; ---------------------------------------------------------------------------
       ;; remove TAGS based xref lookup, we don't use that here anymore.
       (setq xref-backend-functions (remq 'etags--xref-backend xref-backend-functions))

       ;; ---------------------------------------------------------------------------
       ;; append `dumb-jump' as a list of xref-backend functions.
       ;; concertely this configuration uses `dumb-jump' when language
       ;; specific xref don't return anything pertinent.
       ;;
       ;; to *always* use `dumb-jump' use this configuration :
       ;;   (add-to-list 'xref-backend-functions #'dumb-jump-xref-activate)
       (add-to-list 'xref-backend-functions #'dumb-jump-xref-activate t)

       )

   #+end_src

** RipGrep

   + RipGrep is a wrapper over the ripgrep command line tool, and it
     provides a superb interface to the formidable =ripgrep= tool.

   + It allows us to interactively create searches, performing
     automatic searches based on editing context, refining and
     modifying search results, specifying custom query commands
     etc. etc.

   #+begin_src emacs-lisp

     (use-package rg
       :ensure
       :after wgrep

       :custom

       ;; ---------------------------------------------------------------------------
       ;; group matches in same file together
       (rg-group-result t)

       ;; ---------------------------------------------------------------------------
       ;; hide most of rg command line when non nil
       (rg-hide-command t)

       ;; ---------------------------------------------------------------------------
       ;; show the columns of matches in the output buffer
       (rg-show-columns nil)

       ;; ---------------------------------------------------------------------------
       ;; show headers in the result
       (rg-show-header t)

       ;; ---------------------------------------------------------------------------
       ;; file aliases added to the 'rg' built-in aliases
       (rg-custom-type-aliases nil)

       ;; ---------------------------------------------------------------------------
       ;; default file alias to use when no alias can be determined
       (rg-default-alias-fallback "all")

       :config

       ;; ---------------------------------------------------------------------------
       ;; ripgrep in project root
       (rg-define-search anupamk:ripgrep-search/rg-vc-or-dir
                         "ripgrep in project-root or $pwd"
                         :query ask
                         :format regexp
                         :files "everything"

                         ;; ---------------------------------------------------------
                         ;; smart setting will trigger an analyze of the
                         ;; search string and if its all lower case, the
                         ;; search will be case insensitive, otherwise it
                         ;; will be case sensitive
                         :rg-ignore-case smart

                         ;; ---------------------------------------------------------
                         ;; select a root-search directory. project-root or
                         ;; current directory
                         :dir (let ((vc (vc-root-dir)))
                                (if vc
                                    vc
                                  default-directory))

                         ;; ---------------------------------------------------------
                         ;; specifies if the final search command line can
                         ;; be modified and confirmed by the user.
                         :confirm prefix
                         :flags ("--hidden -g !.git"))

       ;; ---------------------------------------------------------------------------
       ;; ripgrep for symbol at point in $PWD
       (rg-define-search anupamk:ripgrep-search/rg-ref-in-pwd
                         "ripgrep for symbol at point in $pwd"
                         :query ask
                         :format regexp
                         :files "everything"

                         ;; ---------------------------------------------------------
                         ;; smart setting will trigger an analyze of the
                         ;; search string and if its all lower case, the
                         ;; search will be case insensitive, otherwise it
                         ;; will be case sensitive
                         :rg-ignore-case smart

                         :dir default-directory
                         :confirm prefix
                         :flags ("--hidden -g !.git"))

       (defun anupamk:ripgrep-search/save-search-as-name ()
         "Save `rg' buffer, naming it after the current search query.
          This function is meant to be mapped to a key in `rg-mode-map'."
         (interactive)
         (let ((pattern (car rg-pattern-history)))
           (rg-save-search-as-name (concat "" pattern ""))))

       :bind (("M-s r" . anupamk:ripgrep-search/rg-vc-or-dir)
              ("M-s d" . anupamk:ripgrep-search/rg-ref-in-pwd)

              :map rg-mode-map
              ("s"   . anupamk:ripgrep-search/save-search-as-name)
              ("C-n" . next-line)
              ("C-p" . previous-line)
              ("M-n" . rg-next-file)
              ("M-p" . rg-prev-file))
       )

   #+end_src

** Trying out packages

   + =try= is quite handy, as it allows you to try a package out
     without installing it.

   #+begin_src emacs-lisp

     (use-package try
       :ensure t
       )

   #+end_src

* Window Management

  + The association list in =display-buffer-alist= describes the
    rule-set for controlling the display of windows within an Emacs
    frame.

  + The general idea is to display buffers of a specific group or type
    in a specific location for a smoother aka low-friction end-to-end
    experience.

    #+begin_src emacs-lisp

      (use-package window
        :custom
        (display-buffer-alist
         '(;; left-side window

           ;; ------------------------------------------------------------------------
           ;; right-side window
           ("\\*\\(Help\\|Faces\\|Colors\\).*"
            (display-buffer-in-side-window)
            (window-width . 0.25)
            (side . right)
            (slot . 0)
            (window-parameters . ((mode-line-format . (" "
                                                       mode-line-buffer-identification)))))

           ;; ------------------------------------------------------------------------
           ;; magit needs more space
           ("\\.*magit.*"
            (display-buffer-in-side-window)
            (window-width . 0.30)
            (side . right)
            (slot . 0)
            (window-parameters . ((mode-line-format . (" "
                                                       mode-line-buffer-identification)))))

           ;; ------------------------------------------------------------------------
           ;; top-side window

           ;; ------------------------------------------------------------------------
           ;; bottom-side window
           ("\\*\\(compilation\\|rg\\).*"
            (display-buffer-in-side-window)
            (window-width . 0.20)
            (dedicated . t)
            (side . bottom)
            (slot . 0)
            (window-parameters . ((mode-line-format . (" "
                                                       mode-line-buffer-identification)))))
           ))

        (window-combination-resize t)
        (even-window-sizes 'height-only)
        (window-sides-vertical nil)

        :hook
        ((help-mode . visual-line-mode)
         (custom-mode . visual-line-mode))
        )

      (use-package emacs
        :functions (anupamk:window-utils/display-buffer-at-bottom)

        :config

        ;; ---------------------------------------------------------------------------
        ;; move current buffer to bottom of the frame.
        (defun anupamk:window-utils/display-buffer-at-bottom ()
          "move current buffer to the bottom of the frame. this is useful to take a
            buffer out of a side window."
          (interactive)
          (let ((buffer (current-buffer)))
            (with-current-buffer buffer
              (delete-window)
              (display-buffer-at-bottom buffer `((window-parameters . ((mode-line-format . (" "
                                                                                            mode-line-buffer-identification)))))))))

        :bind
        (("C-c b" . anupamk:window-utils/display-buffer-at-bottom))

        )
    #+end_src

* Language settings

This section is all about configurations and packages that deal with
programming language enhancements

** Project Configuration

   + Since about version =25= or thereabouts, Emacs introduced the
     native project management via =project.el=

     =eglot= (the built-in lsp client), by default, uses that for its
     activities. Let us set that up.

     #+begin_src emacs-lisp

       (use-package project
         :ensure nil

         :functions (anupamk:project-utils/locate-project-root
                     anupamk:project-utils/do-locate-project-root)

         :bind (("C-c p f" . project-find-file)
                ("C-c p r" . project-find-regexp))

         :config

         ;; --------------------------------------------------------------------
         ;; find project root-dir by searching (recursively) through a list of
         ;; project-root-markers.
         (defun anupamk:project-utils/do-locate-project-root (dirname all-marker-lists)
           "find project root directory (starting from DIRNAME) by searching
       for markers defined in ALL-MARKER-LISTS"

           (when all-marker-lists
             (let ((anupamk:project-root (locate-dominating-file dirname (car all-marker-lists))))
               (if (not anupamk:project-root)
                   ;; -------------------------------------------------------------------
                   ;; keep looking ...
                   (anupamk:project-utils/do-locate-project-root dirname (cdr all-marker-lists))

                 ;; ---------------------------------------------------------------------
                 ;; we got a live one
                 (cons 'vc anupamk:project-root)))))

         ;; ---------------------------------------------------------------------------
         ;; just a wrapper over the real thaang
         (defun anupamk:project-utils/locate-project-root (dirname)
           (let ((project-root-markers (list "Cargo.toml"
                                             "WORKSPACE"
                                             "compile_commands.json"
                                             "compile_flags.txt"
                                             ".git")))
             (anupamk:project-utils/do-locate-project-root dirname project-root-markers)))

         (add-hook 'project-find-functions #'anupamk:project-utils/locate-project-root))

     #+end_src

** All programming languages
*** Commonly used keybindings

    #+begin_src emacs-lisp

      (use-package emacs
        :config

        :bind ("C-c C-r"   . recompile)

        )

    #+end_src

*** Automatic comment folding
    Enable auto-filling of comments for all programming modes.

    #+begin_src emacs-lisp

      (use-package emacs
        :hook
        (prog-mode-hook . anupamk:utils/auto-fill-comments))

    #+end_src

*** Data marshalling / un-marshalling
    Enable protobuf

    #+begin_src emacs-lisp

      (use-package protobuf-mode
        :disabled t
        :ensure)

    #+end_src

** Build systems
*** CMake for C/C++ projects

    #+begin_src emacs-lisp
      (use-package cmake-mode
        :ensure)

    #+end_src

*** Bazel

    #+begin_src emacs-lisp

      (use-package bazel
        :ensure)

    #+end_src

** C/C++ Programming

   This is one of the most used modes in day-to-day activities

*** LSP Client Configuration
**** EGLOT

     + Although a bit 'barebones' at times, =eglot= seems to have
       couple of things in its favor. Most notable being almost /zero
       touch/ 'provisioning' and another one being part of Emacs
       itself.

     #+begin_src emacs-lisp

       (use-package eglot
         :ensure
         :delight

         :init

         ;; ---------------------------------------------------------------------------
         ;; host specific clangd executable
         (defvar anupamk:eglot/clangd-executable
           (cond ((or (anupamk:utils/host-name-is "aws-devel-01")
                      (anupamk:utils/host-name-is "pnq-dev-01.pnq.taranawireless.com"))
                  "/usr/bin/clangd-11")

                 (t (executable-find "clangd")))
           "clangd-executable value")

         ;; ---------------------------------------------------------------------------
         ;; final executable string that we use
         (defvar anupamk:eglot/clangd-exec-cmdstr
           (list anupamk:eglot/clangd-executable

                 ;; -------------------------------------------------------------------
                 ;; clangd arguments

                 ;; 8 threads (4 -> 8) we have cpu cores to burn
                 "-j=8"

                 ;; include index symbols not defined in scopes as well
                 "--all-scopes-completion=1"

                 ;; background indexing is enabled
                 "--background-index=1"

                 ;; 128 results are enough for anyone
                 "--limit-results=128"

                 ;; enable cross file renaming
                 "--cross-file-rename"

                 ;; detailed completion i.e. One completion item for each
                 ;; semantically distinct completion, with full type
                 ;; information
                 "--completion-style=detailed"

                 ;; info level logging
                 "--log=error")

           "clangd executable string")

         :config
         ;; ---------------------------------------------------------------------------
         ;; dont care about using eglot anywhere else...
         (setq eglot-server-programs nil)
         (add-to-list 'eglot-server-programs (cons (list 'c++-mode 'c-mode) anupamk:eglot/clangd-exec-cmdstr))

         ;; ---------------------------------------------------------------------------
         ;; disable annoying, _distracting_, over-the-top features that serve
         ;; no useful purpose at all (imnsho)
         (setq eglot-ignored-server-capabilites
               '(:documentHighlightProvider    ; highlight symbols automatically
                 :documentSymbolProvider       ; list symbols in a buffer
                 :hoverProvider                ; documentation on hover
                 :signatureHelpProvider        ; function-signature help
                 ))

         :hook
         (c-mode-hook   . eglot-ensure)
         (c++-mode-hook . eglot-ensure))

     #+end_src

*** Font locking

    #+begin_src emacs-lisp

      (use-package modern-cpp-font-lock
        :ensure
        :delight
        :hook (c++-mode . modern-c++-font-lock-mode))

    #+end_src

*** Code formatting

    =clang-format= seems to be quite heavily used for large projects,
    and generally does a reasonable job.

      #+begin_src emacs-lisp

        (use-package clang-format
          :ensure)

      #+end_src

*** Some utility functions

    Define some utility functions for working with c/c++ sources.

    #+begin_src emacs-lisp

      (use-package emacs
        :functions (anupamk:cc-utils/compile-eventually
                    anupamk:cc-utils/compile-eventually-with-make
                    anupamk:cc-utils/compile-eventually-with-bazel
                    anupamk:cc-utils/quick-compile-cmdstr
                    anupamk:cc-utils/clang-fmt-and-recenter)
        :config

        (defun anupamk:cc-utils/compile-eventually (search-fname compile-cmdstr)
          "recursively search up the directory tree for 'search-file-name',
      and when found, run 'compile-cmdstr'"

          ;; find the root of the development-tree
          (defvar search-root-dir (file-name-directory buffer-file-name))
          (defvar devel-root-dir (locate-dominating-file search-root-dir search-fname))

          ;; do the build
          (if devel-root-dir (with-temp-buffer (cd devel-root-dir)
                                               (compile compile-cmdstr))
            (progn  (message (concat "unable to find: '"
                                     search-fname "' within: '"
                                     search-root-dir "', running quick-compile"))
                    (compile (anupamk:cc-utils/quick-compile-cmdstr)))))


        ;; ---------------------------------------------------------------------------
        ;; compile with a makefile
        (defun anupamk:cc-utils/compile-eventually-with-make ()
          "compile with make"
          (interactive)
          (anupamk:cc-utils/compile-eventually "Makefile" "make"))

        ;; ---------------------------------------------------------------------------
        ;; compile with bazel
        (defun anupamk:cc-utils/compile-eventually-with-bazel(target)
          "compile with bazel"
          (interactive)
          (let ((bazel-compile-cmdstr (concat "set -e ; time t3 build --gen-compile-commands -c " target " | cut -c26-")))
            (anupamk:cc-utils/compile-eventually "bazel_build_defs" bazel-compile-cmdstr)))

        ;; ---------------------------------------------------------------------
        ;; quickly compile single source c/c++ programs. it produces final
        ;; executable in the 'obj' sub-directory. the executable is called
        ;; `file-name' without the extension
        ;;
        ;; this, a file called `<some-path>/foo.cpp' will produce an
        ;; executable called `<some-path>/obj/foo'
        (defun anupamk:cc-utils/quick-compile-cmdstr()
          "quick compile single-file c/c++ programs"

          ;; -------------------------------------------------------------------
          ;; how we build c/c++ sources are almost fixed
          ;;     -fdiagnostics-color=never ==> no ansii colorized output
          (defvar qc-cmd-prefix:c   "gcc -fdiagnostics-color=never -std=c99 -g -O2 -Wall -o obj/")
          (defvar qc-cmd-prefix:cpp "g++ -fdiagnostics-color=never -std=c++20 -g -O2 -Wall -o obj/")

          ;; first setup the appropriate compilation command based on buffer
          ;; major-mode
          (setq-local compile-command
                      (format "%s%s %s"
                              ;; %s: 'qc-cmd-prefix:{c,cpp}'
                              (if (eq major-mode 'c-mode)
                                  qc-cmd-prefix:c
                                qc-cmd-prefix:cpp)

                              ;; %s: 'obj/<file-name>'
                              (file-name-nondirectory (file-name-sans-extension (buffer-file-name)))

                              ;; %s: '<file-name>.{c,cpp}'
                              (file-name-nondirectory (buffer-file-name)))))

        ;; ---------------------------------------------------------------------------
        ;; format through clang-format
        (defun anupamk:cc-utils/clang-fmt-and-recenter ()
          (interactive)
          (clang-format-buffer)
          (recenter))

        )


    #+end_src

*** C/C++ Mode Configuration

    #+begin_src emacs-lisp

      (use-package cc-mode
        :ensure
        :functions (anupamk:cc/common-mode-hook
                    anupamk:cc/c++-mode-hook
                    anupamk:cc/c-mode-hook)

        :init

        (defvar anupamk:cc/c-basic-offset
          (cond ((or (anupamk:utils/host-name-is "aws-devel-01")
                     (anupamk:utils/host-name-is "pnq-dev-01.pnq.taranawireless.com"))
                 2)                           ; yeech
                (t 8))                        ; sanity
          "host specific cc-mode basic-offset")


        (defvar anupamk:cc/tab-width
          (cond ((or (anupamk:utils/host-name-is "aws-devel-01")
                     (anupamk:utils/host-name-is "pnq-dev-01.pnq.taranawireless.com"))
                 2)                           ; yeech
                (t 8))                        ; sanity
          "host specific cc-mode tab-width")


        (defun anupamk:cc/common-mode-hook ()
          ;; -------------------------------------------------------------------------
          ;; '_' is not a modifier anymore
          (modify-syntax-entry ?_ "w")

          ;; -------------------------------------------------------------------------
          ;; any specific code-fmt'ing related changes
          (setf c-basic-offset anupamk:cc/c-basic-offset

                ;; -------------------------------------------------------------------
                ;; Distance between tab stops (for display of tab
                ;; characters), in columns.
                tab-width anupamk:cc/tab-width

                ;; -------------------------------------------------------------------
                ;; spaces instead of tabs :)
                indent-tabs-mode nil

                ;; -------------------------------------------------------------------
                ;; column beyond which automatic line-wrapping should happen.
                fill-column 80

                ;; -------------------------------------------------------------------
                ;; column to indent right-margin comments to...
                comment-column 60

                ;; -------------------------------------------------------------------
                ;; Specifies how M-x indent-for-comment should handle
                ;; comment-only lines. When this variable is non-nil,
                ;; comment-only lines are indented according to syntactic
                ;; analysis via `c-offsets-alist'.  Otherwise, the comment
                ;; is indented as if it was preceded by code.  Note that
                ;; this variable does not affect how the normal line
                ;; indentation treats comment-only lines.
                c-indent-comments-syntactically-p t)

          ;; -------------------------------------------------------------------------
          ;; syntax-help:
          ;;
          ;;  +   c-basic-offset times 1
          ;;  -   c-basic-offset times -1
          ;;  ++  c-basic-offset times 2
          ;;  --  c-basic-offset times -2
          ;;  *   c-basic-offset times 0.5
          ;;  /   c-basic-offset times -0.5
          (c-set-offset 'case-label '+)
          (c-set-offset 'access-label '/)
          (c-set-offset 'label '/)

          ;; -------------------------------------------------------------------------
          ;; clang-format c/c++ *only* files before save
          ;;
          ;; when `add-hook' is invoked with a non-nil 4th argument (as
          ;; here), the hook's buffer-local value is modified rather than
          ;; the global value. thereby, effectively making the hook
          ;; buffer-local.
          (add-hook 'before-save-hook #'clang-format-buffer nil t))

        (defun anupamk:cc/c++-mode-hook ()
          (anupamk:cc/common-mode-hook)
          (setq comment-start "///")
          (setq comment-end ""))

        (defun anupamk:cc/c-mode-hook ()
          (anupamk:cc/common-mode-hook))

        :config
        ;; ---------------------------------------------------------------------------
        ;; one true style
        (add-to-list 'c-default-style '(c-mode . "k&r"))

        ;; ---------------------------------------------------------------------------
        ;; jump directly to source when we see compilation errors
        (add-to-list 'compilation-search-path (getenv "PWD"))

        ;; ---------------------------------------------------------------------------
        ;; add our mode specific hooks
        :hook
        (c-mode-hook   . anupamk:cc/c-mode-hook)
        (c++-mode-hook . anupamk:cc/c++-mode-hook))



    #+end_src

*** Setup keybindings

    #+begin_src emacs-lisp

      (use-package emacs
        :config
        (define-key c-mode-map (kbd "RET")     #'newline-and-indent)
        (define-key c-mode-map (kbd "C-<ret>") #'recompile)

        ;; ---------------------------------------------------------------------------
        ;; host specific bindings: just update the global-map rather than
        ;; the mode-specific map. this is just for convenience
        ;; ---------------------------------------------------------------------------

        ;; ---------------------------------------------------------------------------
        ;; use make usually
        (when  (or (anupamk:utils/host-name-is "virat")
                   (anupamk:utils/host-name-is "fatcat"))
          (global-set-key (kbd "C-<return>") #'anupamk:cc-utils/compile-eventually-with-make))


        ;; ---------------------------------------------------------------------------
        ;; use bazel un-usually :)
        (when (or (anupamk:utils/host-name-is "pnq-dev-01.pnq.taranawireless.com")
                  (anupamk:utils/host-name-is "aws-devel-01"))
          (global-set-key (kbd "C-<f2>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.b10.1xx")))
          (global-set-key (kbd "C-<f3>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.r10.xxx")))
          (global-set-key (kbd "C-<f4>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.p10.xx")))
          (global-set-key (kbd "C-<f5>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.h10.1xx")))
          (global-set-key (kbd "C-<f6>") (lambda() (interactive) (anupamk:cc-utils/compile-eventually-with-bazel "cap.a3.h10.2xx")))
          ))

    #+end_src

** Python Programming

   + =elpy= strives to give IDE like features for programming in
     python within Emacs. Set that up here.

   + Following packages also need to be =pip= installed to get
     the most bhang-for-buck: =jedi=, =autopep8=, =flake8=, =ipython=,
     =importmagic= and =yapf=.

   #+begin_src emacs-lisp

     ;; -----------------------------------------------------------------------------
     ;; on the fly syntax check feedback
     (use-package flycheck
       :ensure)

     ;; -----------------------------------------------------------------------------
     ;; use `black' for formatting, `elpy' recognizes it, and enables it
     ;; automatically on file-save
     (use-package blacken
       :ensure
       :config
       (setq blacken-line-length 80))

     ;; -----------------------------------------------------------------------------
     ;; completion using jedi
     (use-package jedi
       :ensure
       :config
       ;; ---------------------------------------------------------------------------
       ;; automatically start completion after inserting a '.' character
       (setq jedi:complete-on-dot t))

     ;; -----------------------------------------------------------------------------
     ;; the package that ties all other packages together
     (use-package elpy
       :ensure

       :init
       (elpy-enable)

       :bind
       (:map elpy-mode-map
             ("C-M-n" . elpy-nav-forward-block)
             ("C-M-p" . elpy-nav-backward-block))

       :hook ((elpy-mode-hook . flycheck-mode)
              (elpy-mode-hook . blacken-mode)
              (elpy-mode-hook . jedi:setup))

       :config

       ;; ---------------------------------------------------------------------------
       ;; remove flymake
       (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))

       ;; ---------------------------------------------------------------------------
       ;; don't echo python's shell output in the echo area after input
       ;; has been sent to the shell
       (setq elpy-shell-echo-output nil)

       ;; ---------------------------------------------------------------------------
       ;; setup python interpreter for the rpc backend
       (setq elpy-rpc-python-command "python3")
       (setq elpy-rpc-timeout 2)

       ;; ---------------------------------------------------------------------------
       ;; the python interpreter
       (setq python-shell-interpreter "ipython3")
       (setq python-shell-interpreter-args "--simple-prompt -i"))

   #+end_src

** Shell Scripting
** Lua Programming

   + [[https://www.lua.org/][Lua]] is a powerful, efficient, embeddable scripting language. It
     supports procedural programming, object-oriented programming,
     functional programming, data-driven programming, and data
     description.

   + It is particularly unique in it's use of simple procedural syntax
     and powerful data description constructs (based on associatve
     arrays). Lua is dynamically typed and the bytecode interpreter
     runs a register based VM.

   + It is an /excellent/ choice for configuration management for
     programs as opposed to things like JSON/XML/YAML etc. etc.

     #+begin_src emacs-lisp

       ;; -----------------------------------------------------------------------------
       ;; lets just go with the basics here. will add things as and when required.
       (use-package lua-mode
         :ensure t
         )

     #+end_src

** Elisp Programming

   + Some useful packages for programming in elisp

     #+begin_src emacs-lisp

       ;; -----------------------------------------------------------------------------
       ;; structured and fast editing of s-expressions
       (use-package paredit
         :ensure t)

       ;; -----------------------------------------------------------------------------
       ;; different colors for parenthesis at different levels making it
       ;; easier to spot errors etc.
       (use-package rainbow-delimiters
         :ensure t)

       ;; -----------------------------------------------------------------------------
       ;; company provides completion for elisp statements f.e. functions,
       ;; variables etc.
       (use-package company
         :ensure t)


       (use-package emacs
         :functions (anupamk:utils/setup-elisp-programming-environment)

         :config
         (defun anupamk:utils/setup-elisp-programming-environment ()
           "setup various things required for elisp programming"
           (paredit-mode t)
           (rainbow-delimiters-mode t)
           (show-paren-mode 1))

         :hook
         (emacs-lisp-mode-hook . anupamk:utils/setup-elisp-programming-environment)
         (lisp-interaction-mode . anupamk:utils/setup-elisp-programming-environment))

     #+end_src

** Org Mode

*** Preliminaries

    + While editing code blocks in org-mode buffers, we want =<tab>=
      to indent natively.

    + Also, in org-mode buffers we want a =visual-line= which allows
      word-wrap etc. to happen on =visual= lines rather than =logical=
      lines.

    #+begin_src emacs-lisp

      (use-package org
        :ensure
        :functions (anupamk/do-org-mode-setup)

        :config
        (defun anupamk/do-org-mode-setup ()
          "run these commands every time an org-mode buffer starts up"

          ;; -------------------------------------------------------------------------
          ;; indent text according to outline structure
          (org-indent-mode)

          ;; -------------------------------------------------------------------------
          ;; code-blocks within org-mode
          (setq org-src-window-setup 'current-window)
          (setq org-src-fontify-natively t)
          (setq org-src-preserve-indentation t)
          (setq org-src-tab-acts-natively t)
          (setq org-confirm-babel-evaluate nil)
          (setq org-edit-src-content-indentation 0)

          ;; -------------------------------------------------------------------------
          ;; fontify natively
          (setq org-src-fontify-natively t)

          ;; -------------------------------------------------------------------------
          ;; fancy html5 generation
          (setq org-html-html5-fancy t)
          (setq org-html-doctype "html5")

          ;; -------------------------------------------------------------------------
          ;; when `visual-line-mode' is enabled, word-wrap is turned on, and
          ;; simple editing commands are redefined to act on visual lines, not
          ;; logical lines.
          (visual-line-mode 1))

        :hook (org-mode . anupamk/do-org-mode-setup))

    #+end_src

*** Easy addition of source blocks

    + Since version 9.2, org-mode has moved to a new mechanism called
      /structured-template/. Which makes it a bit harder to add
      source-code blocks.

    + Bring the old easy templating system back via =org-tempo= and
      minor tweaks. With this configuration I can now say =<el[TAB]=
      which expands into the familiar =#+begin_src emacs-lisp
      ... #+end_src= block.

      #+begin_src emacs-lisp

        (require 'org-tempo)
        (add-to-list 'org-structure-template-alist '("sh"   . "src shell"))
        (add-to-list 'org-structure-template-alist '("el"   . "src emacs-lisp"))
        (add-to-list 'org-structure-template-alist '("py"   . "src python"))

      #+end_src
